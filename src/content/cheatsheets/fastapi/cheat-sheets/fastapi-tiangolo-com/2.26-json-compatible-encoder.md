---
title: "2.26 - JSON Compatible Encoder en FastAPI"
description: "C칩mo convertir modelos Pydantic y tipos complejos en datos listos para guardar en Bases de Datos o serializar a JSON."
tags: ["fastapi", "json", "pydantic", "conversion"]
prompt-version: cheat-sheet-generator-1.1
---

## A - El Problema: "La Pieza Cuadrada en el Agujero Redondo" [游댮]

#### 1. **Introducci칩n:**

Las bases de datos y el formato JSON no entienden de objetos complejos de Python (como clases Pydantic o fechas `datetime`); necesitan datos simples (diccionarios, listas, strings).

#### 2. **Ejemplo:**

```python
from datetime import datetime
from pydantic import BaseModel

class Item(BaseModel):
    title: str
    timestamp: datetime # <--- El problema est치 aqu칤

# Tienes esto (Objeto complejo):
mi_item = Item(title="Laptop", timestamp=datetime.now())

# Tu base de datos (fake_db) espera esto (JSON compatible):
# {
#     "title": "Laptop",
#     "timestamp": "2023-10-05T14:30:00"  <--- String, no objeto datetime
# }

# Si intentas guardar 'mi_item' directo en una DB que espera JSON, fallar치.
```

**Explicaci칩n del ejemplo:**
El objeto `mi_item` es una instancia de una clase. Una base de datos que espera JSON (como MongoDB o incluso un campo JSON en SQL) no sabe c칩mo guardar esa "clase". Adem치s, el tipo `datetime` no existe en JSON; debe convertirse a texto (string).

#### 3. **Desarrollo:**

Imagina que tienes una caja (tu base de datos) donde solo caben fichas est치ndar (diccionarios, listas, textos, n칰meros). T칰 tienes una escultura compleja (tu Modelo Pydantic con fechas). Antes de meter la escultura en la caja, necesitas desmontarla y convertirla en esas fichas est치ndar. Si no haces esta conversi칩n, tu programa lanzar치 un error de tipo.

游댮 **Fundamental:** Si no entiendes que JSON y los Objetos de Python no son lo mismo, tendr치s errores constantes al intentar guardar datos. Es la base de la persistencia de datos en APIs modernas.

## B - La Soluci칩n: `jsonable_encoder` [游리]

#### 1. **Introducci칩n:**

Es una funci칩n que toma tu objeto complejo y lo "traduce" autom치ticamente a tipos de datos nativos de Python (dict, list, str, int) que son 100% compatibles con JSON.

#### 2. **Ejemplo:**

```python
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder # <--- Importamos la herramienta
from pydantic import BaseModel
from datetime import datetime

app = FastAPI()
fake_db = {}

class Item(BaseModel):
    title: str
    timestamp: datetime

@app.put("/items/{id}")
def update_item(id: str, item: Item):
    # 1. Recibimos 'item' como un Modelo Pydantic complejo.

    # 2. Usamos la varita m치gica:
    json_compatible_item_data = jsonable_encoder(item)

    # 3. Ahora 'json_compatible_item_data' es un diccionario puro.
    #    El datetime se convirti칩 en string autom치ticamente.

    fake_db[id] = json_compatible_item_data # <--- Ahora s칤 entra en la DB

    return fake_db[id]
```

**Explicaci칩n del ejemplo:**
`jsonable_encoder(item)` escanea el objeto `item`. Ve que es un modelo Pydantic y lo convierte a `dict`. Ve que tiene un `datetime` dentro y lo convierte a un `str` en formato ISO. Hace el trabajo sucio por ti.

#### 3. **Desarrollo:**

FastAPI usa esta misma herramienta internamente cada vez que devuelves algo en tus endpoints. Sin embargo, te la "presta" para que la uses manualmente cuando necesites guardar cosas en una base de datos (`fake_db` en el ejemplo) que requiera datos limpios y serializables.

游리 **Importante:** Es la herramienta est치ndar de FastAPI para preparar datos antes de guardarlos. Te ahorra escribir convertidores manuales para fechas o modelos.

## C - El Resultado: 쮻iccionario o String? (La Trampa Com칰n) [游리]

#### 1. **Introducci칩n:**

`jsonable_encoder` devuelve una **estructura de datos de Python** (como un `dict`), **NO** devuelve un texto (string) con formato JSON.

#### 2. **Ejemplo:**

```python
item = Item(title="Mesa", timestamp=datetime(2023, 1, 1))

datos = jsonable_encoder(item)

# LO QUE OBTIENES (Estructura Python):
print(type(datos))
# Output: <class 'dict'>
# Contenido: {'title': 'Mesa', 'timestamp': '2023-01-01T00:00:00'}

# LO QUE NO OBTIENES (String JSON):
# NO es esto: '{"title": "Mesa", ...}' <--- Esto ser칤a un string
```

**Explicaci칩n del ejemplo:**
Es vital entender que el resultado sigue siendo un objeto manipulable en Python (puedes hacer `datos['title']`). No es un bloque de texto cerrado.

#### 3. **Desarrollo:**

Aqu칤 es donde mi paranoia de profesor se activa: **No confundas "Codificador Compatible con JSON" con "Serializador a JSON"**.

- `jsonable_encoder`: Prepara los ingredientes (convierte objetos raros en diccionarios y listas). El resultado es compatible con `json.dumps()`.
- `json.dumps()`: Toma esos ingredientes y los cocina en un String final.

Si necesitas enviar los datos a una DB que acepta diccionarios (como MongoDB), usas el resultado de `jsonable_encoder` directamente. Si necesitas guardar en un archivo de texto `.json`, tomar칤as el resultado de `jsonable_encoder` y _luego_ usar칤as `json.dump`.

游리 **Importante:** Distinguir entre un `dict` compatible con JSON y un `string` JSON evita bugs donde intentas acceder a propiedades de un string o intentas serializar algo dos veces.
