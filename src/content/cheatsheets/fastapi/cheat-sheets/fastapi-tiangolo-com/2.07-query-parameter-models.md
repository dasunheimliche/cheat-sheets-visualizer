---
title: "2.07 - Modelos para Par치metros de Consulta (Query Params)"
description: "C칩mo agrupar m칰ltiples par치metros de URL en una sola clase limpia y reutilizable."
tags: ["fastapi", "pydantic", "query parameters", "clean code"]
---

## A - Query Parameter Models: "La Caja de Herramientas" [游리]

#### 1. **Introducci칩n:**

En lugar de declarar tus par치metros de consulta (query params) uno por uno en la funci칩n (lo que puede volverse un desorden si tienes muchos), creas una clase (un modelo Pydantic) que los agrupe todos.

#### 2. **Ejemplo:**

Imaginas que tienes un endpoint de b칰squeda con muchos filtros.

**Sin Modelos (El m칠todo "desordenado"):**

```python
# Tienes que repetir todo esto si otro endpoint usa los mismos filtros
@app.get("/items/")
async def read_items(limit: int = 100, offset: int = 0, order_by: str = "created_at", tags: list[str] = []):
    return {"limit": limit, "tags": tags}
```

**Con Query Parameter Models (El m칠todo "limpio"):**

```python
# Defines los filtros una sola vez en una clase
class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

# Tu funci칩n queda limpia y reutilizas la l칩gica
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query
```

#### 3. **Desarrollo:**

Piensa en esto como pasar de llevar las herramientas sueltas en las manos a usar una **caja de herramientas**.

- **Reutilizaci칩n:** Si tienes 3 endpoints que necesitan paginaci칩n y filtrado, usas el mismo modelo `FilterParams` en los tres. No repites c칩digo.
- **Validaci칩n Centralizada:** Las reglas (como que `limit` no sea mayor a 100) viven en el modelo, no en la funci칩n.
- **Nota de Versi칩n:** 游뱁 춰Ojo! Esto funciona a partir de **FastAPI 0.115.0**. Si usas una versi칩n vieja, esto te dar치 error.

游리 **Importante:** Aunque puedes vivir sin esto declarando variables sueltas, usar modelos es una "buena pr치ctica" vital para mantener tu c칩digo limpio cuando la aplicaci칩n crece.

---

## B - Implementaci칩n con `Annotated` y `Query` [游댮]

#### 1. **Introducci칩n:**

Para que FastAPI entienda que ese modelo Pydantic debe llenarse con datos que vienen de la **URL** (Query Params) y no del cuerpo (Body), debemos usar `Annotated` junto con `Query()`.

#### 2. **Ejemplo:**

```python
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

# 1. Defines el modelo
class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

# 2. Lo inyectas en la ruta
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    # FastAPI busca 'limit', 'offset', etc. en la URL autom치ticamente
    return filter_query
```

**Explicaci칩n del ejemplo:**
Cuando llamas a `Annotated[FilterParams, Query()]`, le est치s gritando a FastAPI: _"춰Oye! Usa la estructura de `FilterParams`, pero busca los datos en los **Query Parameters** de la URL"_. Si olvidaras poner `Query()`, FastAPI podr칤a confundirse y pensar que esperas un JSON en el cuerpo de la petici칩n (Body).

#### 3. **Desarrollo:**

FastAPI **extrae** los datos campo por campo. Si la URL es `/items/?limit=50&tags=a&tags=b`, FastAPI:

1.  Lee `limit=50`.
2.  Lee `tags=['a', 'b']`.
3.  Valida los datos.
4.  Crea una instancia de `FilterParams` y te la entrega en la variable `filter_query`.

游댮 **Fundamental:** Esta es la mec치nica central de esta funcionalidad. Entender que `Query()` es el "puente" entre la URL y tu modelo Pydantic es clave.

---

## C - Comparativa: `Annotated` vs Declaraci칩n Cl치sica [游댯]

#### 1. **Introducci칩n:**

Ver치s en la documentaci칩n (y en c칩digo antiguo) que hay dos formas de escribir esto. FastAPI recomienda fuertemente usar `Annotated`.

#### 2. **Ejemplo:**

**Opci칩n A: Recomendada (Annotated)** 游녨

```python
async def read_items(filter_query: Annotated[FilterParams, Query()]):
```

**Opci칩n B: Cl치sica / Antigua** 游녩

```python
async def read_items(filter_query: FilterParams = Query()):
```

#### 3. **Desarrollo:**

쯇or qu칠 elegir una sobre la otra?

- **Annotated (Opci칩n A):** Es el est치ndar moderno de Python. Permite que otras herramientas (no solo FastAPI) entiendan mejor tu c칩digo y es m치s compatible con linters y editores de c칩digo.
- **Cl치sica (Opci칩n B):** Funciona igual en tiempo de ejecuci칩n, pero se considera un estilo "legacy" (heredado).

游댯 **Espec칤fico:** Si est치s empezando, usa siempre **Annotated**. Solo te muestro la otra opci칩n para que no te asustes si la ves en un tutorial viejo o en la documentaci칩n de versiones anteriores.

---

## D - Forbid Extra: "El Portero Estricto" [游댯]

#### 1. **Introducci칩n:**

A veces quieres ser muy estricto y lanzar un error si el cliente env칤a par치metros en la URL que t칰 no definiste en tu modelo.

#### 2. **Ejemplo:**

```python
class FilterParams(BaseModel):
    # Esta l칤nea m치gica activa el modo estricto
    model_config = {"extra": "forbid"}

    limit: int = Field(100)
    offset: int = Field(0)

@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query
```

**Resultado si env칤an basura:**
Si alguien llama a: `https://example.com/items/?limit=10&tool=plumbus`
Recibir치 un error 422:

```json
{
  "type": "extra_forbidden",
  "msg": "Extra inputs are not permitted",
  "input": "plumbus"
}
```

#### 3. **Desarrollo:**

Por defecto, FastAPI ignora los par치metros extra que vienen en la URL. Si configuras `model_config = {"extra": "forbid"}` dentro de tu modelo Pydantic, cambias ese comportamiento para prohibirlos expl칤citamente.

游댯 **Espec칤fico:** 칔til para APIs p칰blicas muy estrictas donde quieres educar al usuario sobre qu칠 par치metros existen realmente y evitar que crean que un par치metro inventado est치 teniendo alg칰n efecto.

---

## E - Visualizaci칩n en Docs [游리]

#### 1. **Introducci칩n:**

Aunque uses un Modelo para agrupar todo, la documentaci칩n autom치tica (Swagger UI) es lo suficientemente inteligente para "desempaquetarlo" visualmente.

#### 2. **Ejemplo:**

No ver치s una sola caja JSON, sino cada campo del modelo listado individualmente como par치metros de consulta:

![Query Params en Docs](https://fastapi.tiangolo.com/img/tutorial/query-param-models/image01.png)

#### 3. **Desarrollo:**

Esto es genial porque mantiene la documentaci칩n f치cil de leer para quien consume tu API. No tienen que saber que t칰 usaste una clase `FilterParams` internamente; ellos solo ven los par치metros `limit`, `offset`, etc., listos para ser llenados.

游리 **Importante:** Verifica siempre en `/docs` que tus par치metros aparecen como esperas. Es tu mejor herramienta de depuraci칩n.
