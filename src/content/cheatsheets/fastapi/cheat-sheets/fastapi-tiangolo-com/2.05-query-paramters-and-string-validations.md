---
title: "2.05 - Validaciones y Metadata en Query Parameters"
description: "Domina los par√°metros de consulta en FastAPI: validaciones de texto, listas, alias y la transici√≥n a Annotated."
tags: ["fastapi", "python", "validation", "query-params"]
---

## A - Par√°metros de Query Opcionales B√°sicos [üî¥ Fundamental]

#### 1. **Introducci√≥n:**

En FastAPI, si defines un par√°metro de funci√≥n con un valor por defecto de `None`, autom√°ticamente se convierte en un par√°metro de consulta (query param) **opcional**.

#### 2. **Ejemplo:**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/")
async def read_items(q: str | None = None):
    # q es opcional. Si no viene en la URL, vale None.
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results
```

#### 3. **Desarrollo:**

FastAPI es muy listo. Al ver `q: str | None = None`, entiende tres cosas:

1.  Es un **Query Parameter** (porque es un tipo simple como `str`).
2.  Es **Opcional** (porque tiene un valor por defecto).
3.  Su valor por defecto es `None` (as√≠ que no es requerido).

Esto permite que tu editor te ayude con el autocompletado y detecci√≥n de errores gracias al tipado `str | None` (o `Union[str, None]` en versiones viejas).

---

## B - A√±adiendo Validaciones con `Annotated` y `Query` [üî¥ Fundamental]

#### 1. **Introducci√≥n:**

Para poner reglas (como longitud m√°xima) a un par√°metro, necesitamos importar `Query` y envolver nuestro tipo dentro de `Annotated`.

#### 2. **Ejemplo:**

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/")
# Le decimos: q es un str o None. Y ADEM√ÅS (Annotated), usa Query para validar que el largo m√°ximo sea 50.
async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results
```

#### 3. **Desarrollo:**

Aqu√≠ es donde la magia ocurre. `Annotated` nos permite a√±adir "metadatos" a un tipo de Python.

- **Antes:** `q: str = ...` (Solo dec√≠amos que era texto).
- **Ahora:** `q: Annotated[str, Query(...)] = ...` (Decimos que es texto Y tiene reglas de `Query`).

FastAPI usar√° esto para:

1.  **Validar** el dato (si mandan 51 caracteres, dar√° error).
2.  Mostrar un **error claro** al cliente.
3.  **Documentar** esta restricci√≥n en la interfaz autom√°tica (Swagger UI).

---

## C - `Annotated` vs. `Query` como valor por defecto (La Trampa) [üü° Importante]

#### 1. **Introducci√≥n:**

Existen dos formas de definir validaciones: la "Nueva/Recomendada" (usando `Annotated`) y la "Vieja" (usando `Query` como valor por defecto). Debes saber distinguir ambas.

#### 2. **Ejemplo Comparativo:**

**‚úÖ La forma Recomendada (Annotated):**

```python
# El valor por defecto (= None) es un valor real de Python.
q: Annotated[str | None, Query(max_length=50)] = None
```

**‚ùå La forma Antigua (Query como default):**

```python
# El valor por defecto se define DENTRO de Query. Confuso para editores de c√≥digo.
q: str | None = Query(default=None, max_length=50)
```

#### 3. **Desarrollo:**

**¬°Atenci√≥n aqu√≠!** Esta es la fuente de confusi√≥n #1.

- **¬øPor qu√© cambiar?**

  - En la forma antigua, le dec√≠as a Python que el valor por defecto de `q` era un objeto `Query(...)`. Eso confund√≠a a los editores de c√≥digo y a otras herramientas (como Typer), porque esperaban un `str` o `None`, no un objeto `Query`.
  - Con `Annotated`, el valor por defecto de la funci√≥n es `= None` (o el string que quieras). Esto es **Python puro y v√°lido**. `Query(...)` vive solo como informaci√≥n extra dentro del tipo.

- **La Trampa:** Si usas `Annotated`, **NO** pongas el `default` dentro de `Query()`. Ponlo al final, como en cualquier funci√≥n normal de Python.
  - _Mal:_ `q: Annotated[str, Query(default="rick")]` ‚ùå
  - _Bien:_ `q: Annotated[str, Query()] = "rick"` ‚úÖ

---

## D - M√°s Validaciones: Min/Max Length [üü° Importante]

#### 1. **Introducci√≥n:**

Puedes combinar longitud m√≠nima y m√°xima para restringir el tama√±o del texto recibido.

#### 2. **Ejemplo:**

```python
async def read_items(
    q: Annotated[str | None, Query(min_length=3, max_length=50)] = None,
):
```

#### 3. **Desarrollo:**

Simplemente a√±ade `min_length` a los argumentos de `Query`. Si el usuario env√≠a "ab" (2 letras), FastAPI lanzar√° un error 422 indicando que no cumple la longitud m√≠nima.

---

## E - Expresiones Regulares (Regex) [üîµ Espec√≠fico]

#### 1. **Introducci√≥n:**

Si necesitas que el texto cumpla un formato muy espec√≠fico, usa el par√°metro `pattern` con una Expresi√≥n Regular.

#### 2. **Ejemplo:**

```python
async def read_items(
    # Solo acepta exactamente la palabra "fixedquery" (ejemplo did√°ctico)
    q: Annotated[str | None, Query(pattern="^fixedquery$")] = None,
):
```

#### 3. **Desarrollo:**

- `pattern`: Define la regla. En el ejemplo `^` significa "empieza con", y `$` significa "termina con".
- **Nota de obsolescencia:** En versiones viejas de Pydantic/FastAPI se usaba `regex` en lugar de `pattern`. Si ves c√≥digo viejo con `regex`, debes saber que est√° deprecado; usa `pattern` ahora.

---

## F - Valores por Defecto (Distintos a None) [üü° Importante]

#### 1. **Introducci√≥n:**

Si quieres que el par√°metro sea opcional, pero que tenga un valor predeterminado si el usuario no lo env√≠a, simplemente as√≠gnalo al final.

#### 2. **Ejemplo:**

```python
# Si el usuario no manda 'q', q valdr√° "fixedquery"
async def read_items(q: Annotated[str, Query(min_length=3)] = "fixedquery"):
    ...
```

#### 3. **Desarrollo:**

Al tener un valor por defecto (`= "fixedquery"`), el par√°metro sigue siendo opcional para el cliente. La diferencia es que tu c√≥digo nunca recibir√° `None`, recibir√° el string por defecto o lo que env√≠e el usuario.

---

## G - Par√°metros Requeridos [üî¥ Fundamental]

#### 1. **Introducci√≥n:**

Para hacer un par√°metro **obligatorio** usando `Annotated` y `Query`, simplemente **no** le asignes un valor por defecto al final.

#### 2. **Ejemplo:**

```python
# No hay "= ..." al final. El usuario DEBE enviar 'q'.
async def read_items(q: Annotated[str, Query(min_length=3)]):
    ...
```

#### 3. **Desarrollo:**

A diferencia de Python normal donde los argumentos sin default van primero, FastAPI es flexible. Pero la regla de oro es: **Sin valor por defecto = Requerido**. Si el usuario visita la URL sin `?q=algo`, recibir√° un error indicando que falta el campo.

---

## H - Requerido pero Nullable (El caso extra√±o) [üîµ Espec√≠fico]

#### 1. **Introducci√≥n:**

Puedes forzar al usuario a enviar un par√°metro, pero permitir que ese par√°metro sea `None` (nulo).

#### 2. **Ejemplo:**

```python
# El tipo permite None (str | None), pero NO hay valor por defecto al final.
async def read_items(q: Annotated[str | None, Query(min_length=3)]):
    ...
```

#### 3. **Desarrollo:**

Esto es sutil.

- `q: str | None = None` -> Opcional. Si no lo mandas, es None.
- `q: str | None` (sin default) -> **Requerido**. El cliente _tiene_ que enviar algo, aunque ese "algo" sea un valor nulo (dependiendo de c√≥mo el cliente haga la petici√≥n, esto es m√°s com√∫n en JSON bodies, pero posible en query params).

---

## I - Listas / M√∫ltiples Valores [üü° Importante]

#### 1. **Introducci√≥n:**

Puedes recibir m√∫ltiples valores para el mismo par√°metro (ej: `?q=foo&q=bar`) declarando el tipo como una lista (`list`).

#### 2. **Ejemplo:**

```python
@app.get("/items/")
async def read_items(q: Annotated[list[str] | None, Query()] = None):
    return {"q": q}
# URL: /items/?q=foo&q=bar  --> Resultado: {"q": ["foo", "bar"]}
```

#### 3. **Desarrollo:**

Para que esto funcione como Query Parameter, **debes** usar `Query()` expl√≠citamente (aunque est√© vac√≠o). Si solo pones `q: list[str] = None` sin `Query`, FastAPI podr√≠a intentar leerlo del cuerpo (Body) de la petici√≥n.

- **Nota:** Puedes definir valores por defecto para la lista: `= ["a", "b"]`.
- **Tip:** Usa `list[str]` en lugar de solo `list` para que FastAPI valide que el contenido sean cadenas de texto.

As√≠ se ve en la documentaci√≥n autom√°tica:
![Listas en Docs](https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image02.png)

---

## J - Metadatos: Title y Description [üîµ Espec√≠fico]

#### 1. **Introducci√≥n:**

Puedes enriquecer la documentaci√≥n autom√°tica a√±adiendo un t√≠tulo y una descripci√≥n a tus par√°metros.

#### 2. **Ejemplo:**

```python
async def read_items(
    q: Annotated[str | None, Query(
        title="Query string",
        description="Busca items en la base de datos que coincidan con esto."
    )] = None,
):
```

#### 3. **Desarrollo:**

Esto no afecta la validaci√≥n ni el funcionamiento del c√≥digo, pero es vital para generar una documentaci√≥n (OpenAPI/Swagger) profesional y √∫til para quienes consuman tu API.

---

## K - Alias de Par√°metros [üü° Importante]

#### 1. **Introducci√≥n:**

A veces la URL necesita un par√°metro como `item-query` (con guion), pero en Python `item-query` no es un nombre de variable v√°lido (por el menos `-`). Usamos `alias` para solucionarlo.

#### 2. **Ejemplo:**

```python
async def read_items(
    # En Python se llama 'q', pero en la URL se busca 'item-query'
    q: Annotated[str | None, Query(alias="item-query")] = None
):
    # URL v√°lida: /items/?item-query=valor
```

#### 3. **Desarrollo:**

FastAPI buscar√° en la URL el nombre definido en `alias`. Si lo encuentra, se lo pasar√° a tu variable `q`. Si intentas usar `?q=valor`, no funcionar√°, porque el alias manda.

---

## L - Deprecaci√≥n de Par√°metros [üîµ Espec√≠fico]

#### 1. **Introducci√≥n:**

Si quieres dejar de usar un par√°metro pero no puedes borrarlo a√∫n (para no romper clientes antiguos), m√°rcalo como deprecado.

#### 2. **Ejemplo:**

```python
q: Annotated[str | None, Query(deprecated=True)] = None
```

#### 3. **Desarrollo:**

El par√°metro seguir√° funcionando normalmente, pero en la documentaci√≥n interactiva aparecer√° tachado o con una advertencia visual, indicando a los desarrolladores que deben dejar de usarlo.

![Deprecated en Docs](https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image01.png)

---

## M - Excluir de OpenAPI [üîµ Espec√≠fico]

#### 1. **Introducci√≥n:**

Si tienes un par√°metro "secreto" o de uso interno que no quieres que aparezca en la documentaci√≥n p√∫blica, usa `include_in_schema=False`.

#### 2. **Ejemplo:**

```python
hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None
```

#### 3. **Desarrollo:**

El par√°metro funciona si se env√≠a, pero nadie sabr√° que existe mirando la documentaci√≥n generada autom√°ticamente.

---

## N - Validaci√≥n Personalizada (AfterValidator) [üîµ Espec√≠fico]

#### 1. **Introducci√≥n:**

Cuando `min_length` o `pattern` no son suficientes, puedes inyectar tu propia funci√≥n de validaci√≥n usando `AfterValidator` de Pydantic dentro de `Annotated`.

#### 2. **Ejemplo:**

```python
from pydantic import AfterValidator

def check_valid_id(id: str):
    if not id.startswith(("isbn-", "imdb-")):
        raise ValueError('ID inv√°lido: debe empezar con "isbn-" o "imdb-"')
    return id

async def read_items(
    # Primero valida que sea str, luego ejecuta check_valid_id
    id: Annotated[str | None, AfterValidator(check_valid_id)] = None,
):
    ...
```

#### 3. **Desarrollo:**

Esto es una caracter√≠stica de **Pydantic v2**.

1.  FastAPI valida los tipos b√°sicos.
2.  Luego pasa el valor a tu funci√≥n `check_valid_id`.
3.  Si tu funci√≥n lanza un error, FastAPI devuelve un error 422 al cliente.
4.  Si todo est√° bien, devuelve el valor (posiblemente modificado).

**Nota:** Esto es para validaciones l√≥gicas con los datos que tienes a mano. Si necesitas consultar una base de datos para validar, deber√≠as usar "Dependencias" (tema futuro), no esto.
