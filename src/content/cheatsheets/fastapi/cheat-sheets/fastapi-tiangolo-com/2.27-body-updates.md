---
title: "2.27 - Actualizaci贸n del Body en FastAPI"
description: "Gu铆a definitiva para actualizar datos usando PUT y PATCH sin romper tu base de datos"
tags: ["fastapi", "put", "patch", "pydantic", "jsonable_encoder"]
prompt-version: cheat-sheet-generator-1.1
---

## A - HTTP PUT: Reemplazo Total []

#### 1. **Introducci贸n:**

El m茅todo `PUT` se utiliza cuando quieres **reemplazar** completamente un 铆tem existente por uno nuevo. Es como tirar una caja vieja y poner una nueva en su lugar.

#### 2. **Ejemplo:**

```python
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str | None = None
    price: float | None = None
    tax: float = 10.5 # Valor por defecto

# Simulaci贸n de base de datos
items = {
    "foo": {"name": "Foo", "price": 50.2, "tax": 20.2}
}

@app.put("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    # Convertimos el modelo recibido a un formato compatible con JSON
    update_item_encoded = jsonable_encoder(item)
    # REEMPLAZAMOS lo que hab铆a en 'foo' con lo nuevo
    items[item_id] = update_item_encoded
    return update_item_encoded
```

**Explicaci贸n del ejemplo:**
Aqu铆 definimos una ruta `PUT`. Recibimos un `item` nuevo, lo convertimos a un formato guardable y sobrescribimos la entrada en el diccionario `items`. Lo viejo desaparece, lo nuevo se queda.

#### 3. **Desarrollo:**

[ Fundamental]: Es la forma est谩ndar en REST para actualizar recursos. Debes entender que `PUT` no "mezcla" datos, sino que **sustituye**.

## B - jsonable_encoder: El Traductor de Datos []

#### 1. **Introducci贸n:**

Es una funci贸n de utilidad de FastAPI que convierte tus modelos Pydantic (y otros tipos complejos) en tipos de datos est谩ndar de Python (dict, list, str, int) que pueden convertirse a JSON.

#### 2. **Ejemplo:**

```python
from fastapi.encoders import jsonable_encoder
from datetime import datetime
from pydantic import BaseModel

class Evento(BaseModel):
    inicio: datetime

mi_evento = Evento(inicio=datetime.now())

# La base de datos (o JSON) no entiende el objeto 'datetime', necesita un string.
datos_guardables = jsonable_encoder(mi_evento)

print(datos_guardables)
# Salida: {'inicio': '2023-10-27T10:00:00.123456'} -> 隆Ahora es un string!
```

#### 3. **Desarrollo:**

Muchas bases de datos (especialmente NoSQL como MongoDB) o librer铆as JSON no saben qu茅 hacer con un objeto `datetime` o un modelo Pydantic puro. `jsonable_encoder` hace el trabajo sucio de convertir todo eso a strings, enteros o listas simples antes de que intentes guardarlo y tu c贸digo explote.

[ Importante]: Casi siempre lo usar谩s antes de guardar datos en una base de datos o devolver una respuesta personalizada.

## C - El "Peligro" del Reemplazo con PUT []

#### 1. **Introducci贸n:**

Si usas `PUT` y el usuario no env铆a un campo que tiene un valor por defecto en tu modelo, **ese valor por defecto sobrescribir谩 lo que ten铆as en la base de datos**.

#### 2. **Ejemplo del problema:**

Imagina que en tu base de datos tienes:
`"bar": {"name": "Bar", "price": 62, "tax": 20.2}`

Y tu modelo es:
`class Item(BaseModel): tax: float = 10.5 ...`

Si haces un `PUT` enviando solo el nombre y precio:
`{ "name": "Barz", "price": 3 }`

**Resultado en Base de Datos:**
`"bar": {"name": "Barz", "price": 3, "tax": 10.5}`
_(隆Adi贸s al tax de 20.2! Se reinici贸 al default 10.5)_

#### 3. **Desarrollo:**

[ Fundamental]: Esta es una trampa com煤n. Como `PUT` reemplaza todo el objeto, Pydantic rellena los huecos faltantes con los valores por defecto definidos en la clase (`tax: float = 10.5`). Si quer铆as conservar el `tax` antiguo de `20.2`, lo has perdido porque el input nuevo "naci贸" con `10.5`.

## D - HTTP PATCH: Actualizaci贸n Parcial []

#### 1. **Introducci贸n:**

El m茅todo `PATCH` se utiliza para modificar **solo** los datos que env铆as, dejando el resto de la informaci贸n intacta.

#### 2. **Ejemplo:**

```python
@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    # L贸gica para actualizar solo lo enviado (veremos el c贸digo completo en el concepto H)
    pass
```

#### 3. **Desarrollo:**

[ Importante]: Es la opci贸n m谩s segura y eficiente cuando solo quieres cambiar un campo (ej: cambiar solo el precio sin tocar el nombre ni los impuestos). Aunque FastAPI no te obliga, seguir la convenci贸n `PATCH` para cambios parciales hace tu API m谩s predecible.

## E - Comparativa: PUT vs PATCH []

#### 1. **Introducci贸n:**

Aqu铆 es donde muchos se confunden. Vamos a dejarlo claro con una analog铆a.

#### 2. **La Analog铆a del Formulario:**

- **PUT (Reemplazar):** Tienes un formulario lleno. Lo rompes, tomas un formulario nuevo en blanco, escribes datos nuevos (y si te olvidas de algo, queda en blanco o por defecto) y entregas ese nuevo.
- **PATCH (Parchear):** Tomas el formulario que ya existe, usas "liquid paper" (corrector) solo en la casilla que quieres cambiar, escribes el nuevo valor y dejas el resto tal cual estaba.

#### 3. **Tabla de Decisi贸n:**

| Caracter铆stica      | PUT                                | PATCH                             |
| :------------------ | :--------------------------------- | :-------------------------------- |
| **Acci贸n**          | Reemplazo total                    | Modificaci贸n parcial              |
| **Datos faltantes** | Se asumen como nulos o defaults    | Se ignoran (se mantiene lo viejo) |
| **Uso com煤n**       | Actualizar una entidad entera      | Cambiar 1 o 2 campos              |
| **Riesgo**          | Sobrescribir datos accidentalmente | Requiere m谩s l贸gica de c贸digo     |

[ Fundamental]: Entender esta diferencia es vital para dise帽ar APIs RESTful correctas. **Nota:** Muchos equipos usan solo `PUT` incluso para parciales por pereza, pero `PATCH` es sem谩nticamente lo correcto para actualizaciones parciales.

## F - exclude_unset: El Filtro M谩gico []

#### 1. **Introducci贸n:**

Es un par谩metro de Pydantic que le dice al modelo: "Devu茅lveme un diccionario SOLO con los campos que el usuario envi贸 expl铆citamente en la petici贸n".

#### 2. **Ejemplo:**

```python
# El usuario env铆a: {"price": 30.0}
# El modelo tiene defaults para 'name', 'tax', etc.

# Opci贸n A: Sin filtro
item.model_dump()
# -> {"name": None, "price": 30.0, "tax": 10.5} (隆Trae basura por defecto!)

# Opci贸n B: Con filtro
item.model_dump(exclude_unset=True)
# -> {"price": 30.0} (隆Limpio! Solo lo que el usuario toc贸)
```

#### 3. **Desarrollo:**

[ Importante]: Esta es la pieza clave para hacer funcionar el `PATCH`. Sin `exclude_unset=True`, Pydantic llenar铆a tu actualizaci贸n parcial con valores `None` o defaults, y terminar铆as borrando datos igual que con `PUT`.

_Nota t茅cnica:_ En Pydantic v1 se usaba `.dict(exclude_unset=True)`. En v2 se usa `.model_dump(exclude_unset=True)`. El texto usa `.dict()` por compatibilidad, pero `.model_dump()` es el futuro.

## G - Actualizaci贸n de Modelos (copy/update) []

#### 1. **Introducci贸n:**

Es la t茅cnica para fusionar los datos viejos de la base de datos con los datos nuevos y limpios que acabamos de filtrar.

#### 2. **Ejemplo:**

```python
# 1. Datos viejos de la DB
stored_item_model = Item(**stored_item_data)

# 2. Datos nuevos filtrados (solo lo que cambi贸)
update_data = item.dict(exclude_unset=True)

# 3. Fusi贸n: Crea una copia del viejo, sobrescribiendo con lo nuevo
updated_item = stored_item_model.copy(update=update_data)
```

#### 3. **Desarrollo:**

[ Espec铆fico]: `stored_item_model.copy(update=update_data)` toma el objeto original y le "pega encima" el diccionario de cambios. El resultado es un objeto h铆brido perfecto: mantiene lo viejo que no tocaste y actualiza lo nuevo.

_Nota t茅cnica:_ En Pydantic v2, `.copy()` pasa a ser `.model_copy()`.

## H - Flujo de Trabajo para Actualizaciones Parciales (Recap) []

#### 1. **Introducci贸n:**

Juntando todas las piezas anteriores, as铆 es como se escribe correctamente un endpoint `PATCH` profesional.

#### 2. **Ejemplo Completo:**

```python
@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    # 1. Recuperar datos guardados
    stored_item_data = items[item_id]

    # 2. Convertirlos a modelo Pydantic
    stored_item_model = Item(**stored_item_data)

    # 3. Extraer SOLO lo que el usuario envi贸 (sin defaults)
    update_data = item.dict(exclude_unset=True)

    # 4. Crear copia fusionada (Viejo + Nuevo)
    updated_item = stored_item_model.copy(update=update_data)

    # 5. Convertir a formato guardable y guardar
    items[item_id] = jsonable_encoder(updated_item)

    # 6. Devolver el resultado
    return updated_item
```

#### 3. **Desarrollo:**

[ Importante]: Este patr贸n (Recuperar -> Convertir -> Filtrar Input -> Fusionar -> Guardar) es el est谩ndar de oro en FastAPI para actualizaciones robustas. Apr茅ndelo de memoria.

## I - Validaci贸n en Actualizaciones []

#### 1. **Introducci贸n:**

Aunque sea una actualizaci贸n parcial, FastAPI y Pydantic siguen validando los tipos de datos. Adem谩s, para que `PATCH` funcione bien, tu modelo deber铆a permitir valores opcionales.

#### 2. **Ejemplo:**

Si tu modelo es:
`class Item(BaseModel): name: str` (name es obligatorio)

Y env铆as un PATCH solo con el precio: `{"price": 20}`.
FastAPI dar谩 error porque espera `name`.

Para soportar PATCH real, tus campos deber铆an ser opcionales o tener defaults:
`class Item(BaseModel): name: str | None = None`

#### 3. **Desarrollo:**

[ Espec铆fico]: Si quieres permitir actualizaciones parciales donde se pueda omitir cualquier campo, necesitas un modelo donde todos los campos sean opcionales. A veces se crean dos modelos: `ItemCreate` (todo obligatorio) e `ItemUpdate` (todo opcional).
