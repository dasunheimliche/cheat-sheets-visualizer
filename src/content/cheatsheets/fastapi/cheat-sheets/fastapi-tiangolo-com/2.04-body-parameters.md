---
title: "2.04 - Request Body en FastAPI"
description: "Gu√≠a paso a paso para recibir datos JSON complejos usando Pydantic"
tags: ["fastapi", "pydantic", "json", "http methods"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Request Body vs. Response Body [üî¥]

#### 1. **Introducci√≥n:**

El **Request Body** (cuerpo de la petici√≥n) es lo que el cliente (navegador) te env√≠a a ti. El **Response Body** es lo que t√∫ le respondes.

#### 2. **Ejemplo:**

Imagina que est√°s comprando en Amazon:

- **Request Body:** Los datos de tu tarjeta de cr√©dito y direcci√≥n que env√≠as al hacer clic en "Comprar".
- **Response Body:** La confirmaci√≥n de compra que Amazon te muestra en pantalla.

#### 3. **Desarrollo:**

Tu API casi siempre enviar√° un _Response Body_, pero los clientes no siempre necesitan enviar un _Request Body_ (por ejemplo, si solo piden ver una lista de productos, no env√≠an datos, solo piden). Para declarar un cuerpo de petici√≥n en FastAPI, usamos **Pydantic**.

üî¥ **Fundamental**: Entender la direcci√≥n de los datos es la base de todo desarrollo web. Si no sabes qui√©n env√≠a y qui√©n recibe, te perder√°s.

## B - M√©todos HTTP y la "Trampa" del GET [üü°]

#### 1. **Introducci√≥n:**

Usa `POST`, `PUT`, `DELETE` o `PATCH` para enviar datos. **Nunca** uses `GET` para enviar un cuerpo, aunque t√©cnicamente sea posible.

#### 2. **Ejemplo:**

```python
# ‚úÖ CORRECTO: Usar POST para enviar datos
@app.post("/items/")
async def create_item(item: Item): ...

# ‚ùå PELIGROSO: Usar GET con un cuerpo (body)
@app.get("/items/")
async def read_items(item: Item): ...
# FastAPI lo soporta, pero es mala pr√°ctica.
```

#### 3. **Desarrollo:**

Aunque FastAPI es tan potente que permite enviar cuerpos en peticiones `GET`, las especificaciones HTTP dicen que el comportamiento es "indefinido".

- **La consecuencia:** La documentaci√≥n interactiva (Swagger UI) no mostrar√° el cuerpo si usas `GET`, y muchos proxies (intermediarios en la red) podr√≠an bloquear o borrar esos datos.

üü° **Importante**: Evita dolores de cabeza futuros. Si env√≠as datos complejos, usa POST (o PUT/PATCH). Deja el GET solo para pedir cosas.

## C - Importando Pydantic BaseModel [üî¥]

#### 1. **Introducci√≥n:**

Para definir qu√© datos esperamos recibir, necesitamos la clase base `BaseModel` de la librer√≠a Pydantic.

#### 2. **Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel # <--- Importaci√≥n clave

class Item(BaseModel): # <--- Tu modelo hereda de esto
    name: str
    price: float
```

#### 3. **Desarrollo:**

Pydantic es el motor que valida que los datos sean correctos. Al heredar de `BaseModel`, le est√°s dando superpoderes a tu clase para que sepa leer JSON, validar tipos y reportar errores autom√°ticamente.

üî¥ **Fundamental**: Sin `BaseModel`, tendr√≠as que validar manualmente cada campo del JSON, lo cual es propenso a errores y aburrido.

## D - Creando tu Modelo de Datos [üî¥]

#### 1. **Introducci√≥n:**

Declaras la estructura de tu JSON como una clase de Python con atributos y tipos est√°ndar.

#### 2. **Ejemplo:**

```python
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
```

**Explicaci√≥n del ejemplo:**
Aqu√≠ definimos que esperamos un objeto JSON. `name` y `price` son obligatorios. `description` y `tax` pueden venir o no.

#### 3. **Desarrollo:**

Usa tipos est√°ndar de Python (`str`, `float`, `bool`). FastAPI y Pydantic hacen el trabajo sucio de convertir el JSON entrante a estos tipos.

üî¥ **Fundamental**: Es el contrato que define qu√© datos acepta tu API.

## E - Campos Obligatorios vs. Opcionales [üî¥]

#### 1. **Introducci√≥n:**

Si un atributo tiene un valor por defecto (como `None`), es **opcional**. Si no tiene valor por defecto, es **obligatorio**.

#### 2. **Ejemplo:**

```python
class Item(BaseModel):
    name: str                    # OBLIGATORIO (No tiene valor por defecto)
    price: float = 0.0           # OPCIONAL (Si no se env√≠a, vale 0.0)
    description: str | None = None # OPCIONAL (Si no se env√≠a, vale None)
```

**Explicaci√≥n del ejemplo:**

- JSON v√°lido 1: `{"name": "Foo"}` (Usa los defaults para el resto).
- JSON v√°lido 2: `{"name": "Foo", "price": 10.5}`.
- JSON inv√°lido: `{"price": 10.5}` (Falta `name`).

#### 3. **Desarrollo:**

Usar `None` como valor por defecto es la forma est√°ndar de decir "este dato puede no existir".

üî¥ **Fundamental**: Controlar qu√© datos son estrictamente necesarios y cu√°les no evita errores de validaci√≥n frustrantes para el cliente.

## F - Declarando el Par√°metro en la Funci√≥n [üî¥]

#### 1. **Introducci√≥n:**

Para que FastAPI sepa que debe leer el cuerpo de la petici√≥n, a√±ades el modelo como un par√°metro en tu funci√≥n con su tipo.

#### 2. **Ejemplo:**

```python
@app.post("/items/")
async def create_item(item: Item): # <--- Aqu√≠ ocurre la magia
    return item
```

#### 3. **Desarrollo:**

Al poner `item: Item`, le dices a FastAPI: "Espera un JSON que coincida con la clase `Item`, l√©elo, val√≠dalo y entr√©gamelo en la variable `item`".

üî¥ **Fundamental**: Es el puente entre la definici√≥n del modelo y tu l√≥gica de negocio.

## G - Resultados Autom√°ticos (Lo que FastAPI hace por ti) [üü°]

#### 1. **Introducci√≥n:**

Con solo declarar el tipo, FastAPI realiza autom√°ticamente cuatro tareas complejas.

#### 2. **Ejemplo:**

Si env√≠as el JSON `{"name": "Foo", "price": "42"}` (nota que el precio es un string):
FastAPI lo convierte a `float` autom√°ticamente porque definiste `price: float`.

#### 3. **Desarrollo:**

1.  **Lee** el cuerpo como JSON.
2.  **Convierte** tipos (ej: de string "42" a n√∫mero 42.0).
3.  **Valida** los datos (si env√≠as texto en un campo num√©rico, devuelve error).
4.  **Genera** el esquema JSON para la documentaci√≥n.

üü° **Importante**: Entender que esto ocurre "bajo el cap√≥" te da confianza en los datos que recibes dentro de tu funci√≥n.

## H - Documentaci√≥n y Soporte de Editor [üîµ]

#### 1. **Introducci√≥n:**

Gracias a Pydantic, obtienes documentaci√≥n visual autom√°tica y autocompletado en tu editor de c√≥digo.

#### 2. **Ejemplo:**

**Documentaci√≥n Autom√°tica (Swagger UI):**
![Swagger UI Example](https://fastapi.tiangolo.com/img/tutorial/body/image01.png)
_Muestra exactamente qu√© campos espera tu API._

**Soporte en Editor (VS Code / PyCharm):**
![Editor Autocomplete](https://fastapi.tiangolo.com/img/tutorial/body/image03.png)
_El editor sabe que `item` tiene un atributo `name`._

#### 3. **Desarrollo:**

Esto no es casualidad. FastAPI fue dise√±ado para maximizar el soporte de herramientas. Si usas **PyCharm**, existe un plugin llamado "Pydantic PyCharm Plugin" que mejora a√∫n m√°s esta experiencia.

üîµ **Espec√≠fico**: Mejora tu calidad de vida como desarrollador (DX), aunque el c√≥digo funcionar√≠a igual sin verlo.

## I - Usando el Modelo dentro de la Funci√≥n [üî¥]

#### 1. **Introducci√≥n:**

Dentro de tu funci√≥n, trabajas con el objeto `item` como si fuera una clase normal de Python, accediendo a sus atributos con un punto.

#### 2. **Ejemplo:**

```python
@app.post("/items/")
async def create_item(item: Item):
    # Acceso directo a atributos
    precio_con_impuesto = item.price + item.tax

    # Convertir a diccionario
    item_dict = item.dict() # (Ver nota abajo sobre v1 vs v2)
    return item_dict
```

#### 3. **Desarrollo:**

**Ojo con la versi√≥n de Pydantic:**

- **Pydantic v1:** Se usa `.dict()`.
- **Pydantic v2:** Se renombr√≥ a `.model_dump()`, aunque `.dict()` sigue funcionando por compatibilidad (pero est√° obsoleto/deprecated).
  El texto usa `.dict()` por compatibilidad, pero si empiezas un proyecto nuevo hoy, intenta usar `.model_dump()`.

üî¥ **Fundamental**: As√≠ es como manipulas los datos recibidos para guardar en base de datos, calcular cosas, etc.

## J - Mezclando Body + Path Parameters [üü°]

#### 1. **Introducci√≥n:**

Puedes recibir datos en la URL (Path) y en el JSON (Body) al mismo tiempo. FastAPI sabe cu√°l es cu√°l.

#### 2. **Ejemplo:**

```python
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"id": item_id, "datos": item}
```

**Explicaci√≥n del ejemplo:**

- `item_id`: Coincide con `{item_id}` en la ruta -> **Path Parameter**.
- `item`: Es de tipo `Item` (Pydantic Model) -> **Request Body**.

#### 3. **Desarrollo:**

FastAPI detecta autom√°ticamente: si el nombre del argumento est√° en la URL, es un Path Parameter. Si el tipo es un modelo Pydantic, es un Body.

üü° **Importante**: Muy com√∫n para operaciones de actualizaci√≥n (PUT), donde el ID va en la URL y los datos nuevos en el cuerpo.

## K - Mezclando Body + Path + Query (La Regla de Oro) [üü°]

#### 1. **Introducci√≥n:**

¬øQu√© pasa si tienes los tres tipos? FastAPI usa una l√≥gica simple para distinguirlos.

#### 2. **Ejemplo:**

```python
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,           # Path Parameter (est√° en la ruta)
    item: Item,             # Body (es un modelo Pydantic)
    q: str | None = None    # Query Parameter (tipo simple, no est√° en ruta)
):
    ...
```

#### 3. **Desarrollo:**

La l√≥gica de decisi√≥n de FastAPI es:

1.  ¬øEst√° declarado en la URL (ej: `{item_id}`)? -> **Path Parameter**.
2.  ¬øEs un modelo Pydantic (ej: `Item`)? -> **Request Body**.
3.  ¬øEs un tipo singular (`int`, `float`, `str`, `bool`) y NO est√° en la URL? -> **Query Parameter**.

**Nota sobre `q`:** FastAPI sabe que `q` no es obligatorio no por el tipo `str | None`, sino porque tiene un valor por defecto `= None`.

üü° **Importante**: Entender esta jerarqu√≠a evita que te preguntes "¬øpor qu√© FastAPI cree que mi variable es un query param?".
