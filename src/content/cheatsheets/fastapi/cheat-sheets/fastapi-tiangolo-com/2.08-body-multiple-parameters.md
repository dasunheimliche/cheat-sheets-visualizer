---
title: "2.08 - M칰ltiples Par치metros de Body en FastAPI"
description: "C칩mo gestionar m칰ltiples modelos, valores singulares y la estructura del JSON resultante."
tags: ["fastapi", "body", "json", "parameters"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Mezcla de Par치metros (Path, Query y Body) [游댮]

#### 1. **Introducci칩n:**

FastAPI es lo suficientemente inteligente para distinguir entre par치metros de ruta (en la URL), par치metros de consulta (query params) y el cuerpo del mensaje (body) en una sola funci칩n, sin que tengas que configurarlo manualmente.

#### 2. **Ejemplo:**

```python
from typing import Annotated
from fastapi import FastAPI, Path
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    price: float

@app.put("/items/{item_id}")
async def update_item(
    item_id: Annotated[int, Path(ge=0)], # Path Param (est치 en la URL {})
    q: str | None = None,                # Query Param (es tipo simple y no est치 en Path)
    item: Item | None = None,            # Body Param (es un modelo Pydantic)
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if item:
        results.update({"item": item})
    return results
```

**Explicaci칩n del ejemplo:**
Aqu칤 `item_id` se extrae de la URL, `q` se busca despu칠s del signo `?` en la URL, y `item` se espera como un objeto JSON en el cuerpo de la petici칩n. FastAPI hace el "routing" de cada dato a su variable correcta autom치ticamente.

#### 3. **Desarrollo:**

[游댮 Fundamental]: Es vital entender que no necesitas decoradores especiales para separar estos mundos. FastAPI usa las **declaraciones de tipo** para saber qu칠 hacer:

- Si est치 en el path (`{variable}`): es **Path**.
- Si es un tipo simple (`int`, `str`) y no est치 en el path: es **Query**.
- Si es un modelo Pydantic (`BaseModel`): es **Body**.

---

## B - Par치metros de Body Opcionales [游리]

#### 1. **Introducci칩n:**

Puedes hacer que enviar el cuerpo de la petici칩n (el JSON) no sea obligatorio, simplemente asign치ndole un valor por defecto de `None`.

#### 2. **Ejemplo:**

```python
# En la definici칩n de la funci칩n:
async def update_item(
    item: Item | None = None # El "= None" lo hace opcional
):
    if item:
        return {"message": "Item recibido", "item": item}
    return {"message": "No se envi칩 ning칰n item"}
```

#### 3. **Desarrollo:**

[游리 Importante]: Si no pones `= None`, FastAPI asumir치 que el cuerpo es **requerido** y devolver치 un error al cliente si intenta hacer la petici칩n sin enviar el JSON. Al hacerlo opcional, permites peticiones vac칤as o parciales.

---

## C - M칰ltiples Par치metros de Body (El efecto "Envoltura") [游댮]

#### 1. **Introducci칩n:**

춰Cuidado aqu칤! Si declaras **m치s de un** modelo Pydantic como par치metro, FastAPI cambia la estructura del JSON que espera: deja de ser plano y pasa a esperar un JSON con claves (keys) que coinciden con los nombres de tus argumentos.

#### 2. **Ejemplo:**

```python
class Item(BaseModel):
    name: str
    price: float

class User(BaseModel):
    username: str

# Tienes DOS modelos en la funci칩n: item y user
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User):
    return {"item": item, "user": user}
```

**El JSON que debes enviar AHORA se ve as칤:**

```json
{
  "item": {
    "name": "Foo",
    "price": 42.0
  },
  "user": {
    "username": "dave"
  }
}
```

#### 3. **Desarrollo:**

[游댮 Fundamental]: Esta es la "trampa" m치s com칰n.

- **1 solo par치metro Body:** FastAPI espera el JSON plano (`{"name": "Foo", "price": 42.0}`).
- **2 o m치s par치metros Body:** FastAPI **envuelve** los datos en un objeto padre usando los nombres de las variables (`item` y `user`) como claves.
  FastAPI hace esto autom치ticamente para poder distinguir qu칠 datos pertenecen al `Item` y cu치les al `User`.

---

## D - Valores Singulares en el Body (usando `Body`) [游댯]

#### 1. **Introducci칩n:**

Si quieres enviar un dato simple (como un n칰mero o un string) dentro del JSON, pero no quieres crear un modelo Pydantic entero para ello, debes usar `Body()` para decirle a FastAPI que **no** es un Query param.

#### 2. **Ejemplo:**

```python
from typing import Annotated
from fastapi import Body

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    # importance es un int. Por defecto ser칤a Query.
    # Usamos Body() para forzarlo a estar dentro del JSON.
    importance: Annotated[int, Body()]
):
    return {"importance": importance}
```

**El JSON esperado:**

```json
{
    "item": {...},
    "user": {...},
    "importance": 5
}
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: Por defecto, FastAPI asume que cualquier valor "suelto" (singular) como `int`, `str`, `bool` es un par치metro de **Query** (URL). La funci칩n `Body()` act칰a como una etiqueta que dice: "Oye, aunque esto es solo un n칰mero, b칰scalo dentro del JSON del cuerpo, no en la URL".

---

## E - Coexistencia Total (Body + Query) [游리]

#### 1. **Introducci칩n:**

Puedes mezclar todo lo anterior: m칰ltiples objetos en el body, valores singulares en el body, y adem치s, par치metros de Query normales.

#### 2. **Ejemplo:**

```python
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,                       # Path
    item: Item,                         # Body (dentro de clave "item")
    user: User,                         # Body (dentro de clave "user")
    importance: Annotated[int, Body()], # Body (dentro de clave "importance")
    q: str | None = None                # Query (en la URL ?q=algo)
):
    # ... l칩gica ...
    pass
```

#### 3. **Desarrollo:**

[游리 Importante]: FastAPI no se confunde.

1.  Extrae `item_id` del path.
2.  Busca `q` en los par치metros de la URL.
3.  Toma todo el JSON del cuerpo y busca las claves `item`, `user` e `importance` para rellenar los otros argumentos.

---

## F - `Body(embed=True)` (Forzando la envoltura) [游댯]

#### 1. **Introducci칩n:**

A veces tienes **un solo** modelo (lo que normalmente esperar칤a un JSON plano), pero quieres que el JSON tenga la estructura "envuelta" (con la clave del nombre de la variable), tal vez para ser consistente con otros endpoints que usan m칰ltiples par치metros.

#### 2. **Ejemplo:**

```python
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    # embed=True fuerza a que el JSON tenga la clave "item"
    item: Annotated[Item, Body(embed=True)]
):
    return item
```

**JSON esperado (gracias a `embed=True`):**

```json
{
  "item": {
    "name": "Foo",
    "price": 42.0
  }
}
```

_(Sin `embed=True`, el JSON esperado ser칤a directamente `{"name": "Foo", "price": 42.0}`)_

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: 칔salo cuando necesites que el JSON entrante tenga una clave ra칤z (como `"item": {...}`) aunque solo est칠s pidiendo un 칰nico objeto. Es 칰til para mantener una estructura de API predecible donde todo siempre viene dentro de una clave.
