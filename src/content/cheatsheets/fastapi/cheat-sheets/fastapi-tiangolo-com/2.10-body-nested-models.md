---
title: "2.10 - FastAPI: Modelos Anidados y Estructuras Complejas"
description: "C칩mo definir, validar y documentar estructuras JSON complejas, listas y diccionarios en FastAPI."
tags: ["fastapi", "python", "pydantic", "json", "nested models"]
prompt-version: cheat-sheet-generator-1.1
---

## A - List Fields: Listas Gen칠ricas [游댮]

#### 1. **Introducci칩n:**

Es la forma m치s b치sica de decir "esto es una lista", pero sin especificar qu칠 tipo de datos contiene (podr칤a ser una mezcla de n칰meros y textos, FastAPI no lo validar치 estrictamente).

#### 2. **Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    # Definimos tags como una lista vac칤a por defecto
    tags: list = []

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, "item": item}
```

**Explicaci칩n del ejemplo:**
Aqu칤 `tags` aceptar치 cualquier lista JSON, como `["uno", 2, true]`. FastAPI sabe que es una lista, pero no sabe de qu칠.

#### 3. **Desarrollo:**

Aunque funciona, es un poco "ciego". Al usar solo `list`, pierdes la capacidad de que FastAPI valide si los elementos internos son correctos. Es 칰til si realmente no te importa qu칠 hay dentro de la lista, pero generalmente querremos ser m치s espec칤ficos (ver concepto B).

游댮 **Fundamental:** Es la base para entender colecciones de datos, aunque en producci칩n solemos preferir listas tipadas.

## B - Typed Lists: Listas con "Rayos X" [游댮]

#### 1. **Introducci칩n:**

Aqu칤 es donde le decimos a Python exactamente **qu칠** hay dentro de la lista (por ejemplo: "una lista de solo textos").

#### 2. **Ejemplo:**

```python
# En Python 3.9+
class Item(BaseModel):
    name: str
    # "tags" debe ser una lista, y CADA elemento debe ser un string
    tags: list[str] = []
```

**Explicaci칩n del ejemplo:**
Si intentas enviar `[1, 2]` a este modelo, FastAPI intentar치 convertir esos n칰meros a texto o te dar치 un error si no puede. Ahora el sistema sabe qu칠 esperar.

#### 3. **Desarrollo:**

Esta t칠cnica usa "par치metros de tipo" (los corchetes `[]`). Es vital para la validaci칩n de datos. Si declaras `list[int]`, FastAPI se asegurar치 de que todo lo que entre ah칤 sea un n칰mero entero.

游댮 **Fundamental:** Es la forma est치ndar y recomendada de trabajar con listas para asegurar la integridad de los datos.

## C - Sintaxis de Versiones: `list` vs `List` [游댯]

#### 1. **Introducci칩n:**

Dependiendo de qu칠 tan viejo sea tu Python, la forma de escribir "Lista de algo" cambia ligeramente. 춰Cuidado con esto al copiar c칩digo!

#### 2. **Ejemplo:**

```python
# OPCI칍N 1: Python 3.9 o superior (La forma moderna y recomendada)
tags: list[str] = []

# OPCI칍N 2: Python 3.8 o anterior (La forma antigua)
from typing import List # <--- Necesitas importar esto
tags: List[str] = []
```

#### 3. **Desarrollo:**

- **Python 3.9+:** Usas la palabra reservada est치ndar `list` (en min칰scula).
- **Python 3.8 e inferiores:** Debes importar `List` (con may칰scula) desde el m칩dulo `typing`.

Ambas hacen exactamente lo mismo, pero si usas la sintaxis moderna en un Python viejo, tu programa fallar치.

游댯 **Espec칤fico:** Solo es relevante para mantener compatibilidad con versiones antiguas o entender c칩digo legacy.

## D - Set Types: Listas sin Duplicados [游리]

#### 1. **Introducci칩n:**

쯈u칠 pasa si quieres una lista de etiquetas, pero no quieres que se repita ninguna? Usas un `set` (conjunto) en lugar de una `list`.

#### 2. **Ejemplo:**

```python
class Item(BaseModel):
    name: str
    # Usamos set[str] para elementos 칰nicos
    tags: set[str] = set()

# Si env칤as: {"tags": ["rock", "metal", "rock"]}
# FastAPI lo convierte a: {"tags": ["rock", "metal"]}
```

#### 3. **Desarrollo:**

Python tiene un tipo de dato llamado `set` que matem치ticamente no permite duplicados.

- **La Magia:** Si la petici칩n (request) trae datos repetidos, FastAPI los elimina autom치ticamente antes de entreg치rtelos.
- **La Salida:** Al responder, tambi칠n se enviar치 como un conjunto de elementos 칰nicos.

游리 **Importante:** Es una herramienta muy potente para limpieza de datos autom치tica sin escribir l칩gica extra.

## E - Nested Models: El concepto de Submodelos [游댮]

#### 1. **Introducci칩n:**

En lugar de usar tipos b치sicos (como `str` o `int`), usamos otro modelo Pydantic que creamos nosotros mismos como tipo.

#### 2. **Ejemplo:**

```python
class Image(BaseModel):
    url: str
    name: str

class Item(BaseModel):
    name: str
    # Aqu칤 "Image" es el tipo del campo "image"
    image: Image | None = None
```

**Explicaci칩n del ejemplo:**
Definimos primero `Image`. Luego, dentro de `Item`, decimos que el campo `image` debe cumplir con las reglas del modelo `Image`.

#### 3. **Desarrollo:**

Esto permite crear objetos JSON anidados. FastAPI esperar치 un JSON como:

```json
{
  "name": "Foo",
  "image": {
    "url": "http://...",
    "name": "My Image"
  }
}
```

FastAPI validar치 tanto el `Item` principal como el `Image` interno.

游댮 **Fundamental:** Es la base para construir APIs REST reales, donde los datos raramente son planos.

## F - Special Types: Validaciones "Gratis" (Ej: HttpUrl) [游리]

#### 1. **Introducci칩n:**

Pydantic ofrece tipos especiales que son m치s estrictos que un simple `str`. Por ejemplo, `HttpUrl` verifica que el texto sea una URL v치lida real.

#### 2. **Ejemplo:**

```python
from pydantic import BaseModel, HttpUrl

class Image(BaseModel):
    # No es solo str, debe ser una URL v치lida (http://...)
    url: HttpUrl
    name: str
```

#### 3. **Desarrollo:**

Si usas `str`, alguien podr칤a enviar "hola mundo" como url. Si usas `HttpUrl`, FastAPI rechazar치 esa petici칩n autom치ticamente. Esto te ahorra escribir expresiones regulares o funciones de validaci칩n manuales. Se documenta autom치ticamente en OpenAPI como formato URL.

游리 **Importante:** Ahorra tiempo y errores. 칔salo siempre que el dato tenga un formato espec칤fico (emails, urls, ips, etc.).

## G - Lists of Submodels: Listas de Objetos [游댮]

#### 1. **Introducci칩n:**

Combinamos el concepto de **Listas** (Concepto B) con el de **Submodelos** (Concepto E) para aceptar una lista de objetos complejos.

#### 2. **Ejemplo:**

```python
class Item(BaseModel):
    name: str
    # Una lista donde cada elemento es un objeto Image
    images: list[Image] | None = None
```

**Explicaci칩n del ejemplo:**
Esto espera un JSON as칤:

```json
{
  "name": "Foo",
  "images": [
    { "url": "http://a.com", "name": "A" },
    { "url": "http://b.com", "name": "B" }
  ]
}
```

#### 3. **Desarrollo:**

FastAPI validar치 cada uno de los objetos dentro de la lista contra el modelo `Image`. Si uno solo falla, toda la petici칩n falla.

游댮 **Fundamental:** Extremadamente com칰n en APIs (ej: un post con m칰ltiples comentarios, una factura con m칰ltiples l칤neas de productos).

## H - Deeply Nested Models: Anidaci칩n Profunda [游댯]

#### 1. **Introducci칩n:**

No hay l칤mite. Puedes tener una lista de objetos, que dentro tienen otra lista de otros objetos, y as칤 sucesivamente.

#### 2. **Ejemplo:**

```python
class Image(BaseModel):
    url: HttpUrl
    name: str

class Item(BaseModel):
    name: str
    images: list[Image] | None = None

class Offer(BaseModel):
    name: str
    price: float
    # Offer -> lista de Items -> lista de Images
    items: list[Item]
```

#### 3. **Desarrollo:**

FastAPI maneja esto recursivamente.

- `Offer` tiene una lista de `Item`.
- Cada `Item` tiene una lista de `Image`.
  Todo se valida, se documenta y se convierte autom치ticamente.

游댯 **Espec칤fico:** Aunque es potente, intenta no abusar de la profundidad excesiva para mantener tu API comprensible para los humanos.

## I - Bodies of Pure Lists: Arrays como ra칤z [游댯]

#### 1. **Introducci칩n:**

A veces el JSON que recibes no empieza con llaves `{}`, sino directamente con corchetes `[]`. Es decir, el cuerpo entero es una lista.

#### 2. **Ejemplo:**

```python
# El body NO es un objeto con una clave "images", ES la lista en s칤.
@app.post("/images/multiple/")
async def create_multiple_images(images: list[Image]):
    return images
```

**Explicaci칩n del ejemplo:**
Aqu칤 esperamos recibir: `[{"url": "...", "name": "..."}, {"url": "...", "name": "..."}]`.
No hay una clave envolvente.

#### 3. **Desarrollo:**

Se declara poniendo el tipo `list[Modelo]` directamente en el argumento de la funci칩n de la ruta (path operation function), igual que har칤as con un campo de un modelo Pydantic.

游댯 **Espec칤fico:** Com칰n en operaciones de carga masiva (bulk upload).

## J - Editor Support: La ventaja invisible [游리]

#### 1. **Introducci칩n:**

Gracias a que definimos todo con tipos y modelos, tu editor de c칩digo (VS Code, PyCharm) te ayuda "m치gicamente".

#### 2. **Ejemplo:**

![Editor support](https://fastapi.tiangolo.com/img/tutorial/body-nested-models/image01.png)

#### 3. **Desarrollo:**

Como se ve en la imagen, incluso dentro de un bucle que recorre una lista anidada profundamente, el editor sabe qu칠 campos tiene el objeto (`url`, `name`) y te los sugiere.

- **Comparaci칩n:** Si usaras diccionarios puros (`dict`), el editor no sabr칤a qu칠 claves existen y tendr칤as que memorizarlas.

游리 **Importante:** Esto reduce dr치sticamente los errores de "dedo" (typos) mientras programas.

## K - Arbitrary Dicts: Diccionarios Desconocidos [游댯]

#### 1. **Introducci칩n:**

쯈u칠 pasa si quieres recibir un objeto JSON pero **no sabes** c칩mo se llamar치n las claves? Usas `dict`.

#### 2. **Ejemplo:**

```python
# Esperamos claves enteras (int) y valores decimales (float)
@app.post("/index-weights/")
async def create_index_weights(weights: dict[int, float]):
    return weights
```

**Explicaci칩n del ejemplo:**
Esto aceptar칤a: `{"1": 0.5, "20": 0.9}`.
No sabemos si la clave ser치 "1" o "20" o "500", pero sabemos que debe poder interpretarse como `int`.

#### 3. **Desarrollo:**

Es 칰til cuando las claves son din치micas (por ejemplo, IDs de usuarios o fechas) y no nombres de campos fijos como `name` o `price`.

- Sintaxis: `dict[TipoClave, TipoValor]`.

游댯 **Espec칤fico:** 칔til para casos donde la estructura es flexible pero los tipos de datos son consistentes.

## L - JSON Key Conversion: La trampa de las claves [丘멆잺]

#### 1. **Introducci칩n:**

춰Ojo aqu칤! JSON **solo** permite strings (texto) como claves. No existen claves num칠ricas en JSON puro.

#### 2. **Ejemplo:**

Si env칤as este JSON:

```json
{
  "1": 0.5,
  "2": 0.75
}
```

Y tu modelo espera `dict[int, float]`.

#### 3. **Desarrollo:**

Aunque el JSON t칠cnicamente tiene claves "1" (string), **Pydantic** es lo suficientemente inteligente para convertir autom치ticamente ese "1" a el n칰mero `1` (int) porque as칤 lo definiste en `dict[int, float]`.

- **La Trampa:** El cliente (frontend/postman) debe enviar strings, pero t칰 recibir치s enteros en tu c칩digo Python. 춰Magia de conversi칩n!

丘멆잺 **Advertencia Pedag칩gica:** Recuerda siempre que en el cable (HTTP/JSON) son strings, pero en tu variable `weights` ya ser치n integers.
