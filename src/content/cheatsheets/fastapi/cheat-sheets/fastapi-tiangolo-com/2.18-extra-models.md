---
title: "2.18 - Modelos Extra y Polimorfismo en FastAPI"
description: "Gesti√≥n avanzada de modelos: seguridad, herencia y tipos de respuesta complejos."
tags: ["fastapi", "pydantic", "models", "security", "typing"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Estrategia de M√∫ltiples Modelos: "Divide y Vencer√°s (Seguro)" [üî¥]

#### 1. **Introducci√≥n:**

No uses un solo modelo para todo. Necesitas modelos diferentes para recibir datos (Input), guardarlos (DB) y devolverlos (Output), especialmente por seguridad.

#### 2. **Ejemplo:**

```python
from pydantic import BaseModel

# 1. Input: Lo que el usuario env√≠a (tiene password plana)
class UserIn(BaseModel):
    username: str
    password: str  # ‚ö†Ô∏è Peligroso si se guarda o devuelve as√≠
    email: str

# 2. DB: Lo que guardamos (password hasheada/encriptada)
class UserInDB(BaseModel):
    username: str
    hashed_password: str # ‚úÖ Seguro
    email: str

# 3. Output: Lo que respondemos al cliente (SIN password)
class UserOut(BaseModel):
    username: str
    email: str
    # üö´ Aqu√≠ NO existe ning√∫n campo de password
```

#### 3. **Desarrollo:**

Imagina que usas el mismo modelo para todo. Si tu usuario env√≠a su contrase√±a, y t√∫ usas ese mismo modelo para responderle, ¬°le estar√≠as devolviendo su contrase√±a en texto plano! O peor, guard√°ndola as√≠ en la base de datos.

- **Input Model**: Necesita la contrase√±a original para que el usuario se registre.
- **DB Model**: Necesita la versi√≥n "hasheada" (encriptada) de la contrase√±a. **Nunca guardes texto plano.**
- **Output Model**: Debe filtrar cualquier dato sensible.

üî¥ **Fundamental**: Esta separaci√≥n es la piedra angular de la seguridad de datos en FastAPI. Ignorarla es garantizar una brecha de seguridad.

---

## B - `.dict()` vs `.model_dump()`: La Transici√≥n de Pydantic [üü°]

#### 1. **Introducci√≥n:**

Para convertir tu modelo en un diccionario de Python, Pydantic cambi√≥ el nombre del m√©todo en su versi√≥n 2.

#### 2. **Ejemplo:**

```python
# Tienes un modelo con datos
user = UserIn(username="pepe", password="123", email="pepe@mail.com")

# üë¥ Pydantic v1 (y modo compatibilidad):
datos_v1 = user.dict()

# üë∂ Pydantic v2 (La forma moderna):
datos_v2 = user.model_dump()

print(datos_v1)
# Salida: {'username': 'pepe', 'password': '123', 'email': 'pepe@mail.com'}
```

#### 3. **Desarrollo:**

Aqu√≠ hay una **comparaci√≥n cr√≠tica** que debes entender para no confundirte al leer documentaci√≥n antigua o nueva:

| Caracter√≠stica | `.dict()`                           | `.model_dump()` |
| :------------- | :---------------------------------- | :-------------- |
| **Origen**     | Pydantic v1                         | Pydantic v2     |
| **Estado**     | Obsoleto (Deprecated) pero funciona | **Recomendado** |
| **Uso**        | C√≥digo legado o compatibilidad      | C√≥digo nuevo    |

**¬øCu√°l elijo?**
Si est√°s empezando un proyecto nuevo con versiones recientes de FastAPI/Pydantic, usa **`.model_dump()`**. El texto original usa `.dict()` por compatibilidad, pero te avisa que el futuro es `.model_dump()`.

üü° **Importante**: Ambos hacen lo mismo (darte un diccionario puro de Python), pero usar el nombre nuevo te asegura compatibilidad futura.

---

## C - Desempaquetado (`**`): "Vaciando la bolsa" [üî¥]

#### 1. **Introducci√≥n:**

El operador `**` (doble asterisco) toma un diccionario y "esparce" sus claves y valores como si fueran argumentos individuales al llamar a una funci√≥n o clase.

#### 2. **Ejemplo:**

```python
datos = {
    "username": "juan",
    "email": "juan@mail.com"
}

# Sin desempaquetar (Tendr√≠as que escribir uno por uno):
# User(username=datos["username"], email=datos["email"]) üò´

# CON desempaquetado (Magia ‚ú®):
usuario = User(**datos)
# Python interpreta: User(username="juan", email="juan@mail.com")
```

#### 3. **Desarrollo:**

Piensa en el diccionario `datos` como una bolsa cerrada.

- Si pasas `datos`, pasas la bolsa entera.
- Si pasas `**datos`, abres la bolsa y viertes el contenido sobre la mesa.

üî¥ **Fundamental**: En FastAPI, usar√°s esto constantemente para convertir datos de un modelo a otro sin escribir cada campo manualmente.

---

## D - Conversi√≥n de Modelos y Argumentos Extra [üîµ]

#### 1. **Introducci√≥n:**

Puedes crear un modelo nuevo (ej: para Base de Datos) usando los datos del modelo viejo (Input) y a√±adiendo/sobreescribiendo campos al vuelo.

#### 2. **Ejemplo:**

```python
def guardar_usuario(user_in: UserIn):
    # 1. Convertimos el input a diccionario
    user_dict = user_in.dict() # o .model_dump()

    # 2. Calculamos el hash (simulado)
    hashed_pw = "secreto_" + user_in.password

    # 3. Creamos el modelo de DB mezclando:
    #    - Todo lo que ven√≠a en user_dict (**)
    #    - Y expl√≠citamente el campo hashed_password
    user_db = UserInDB(**user_dict, hashed_password=hashed_pw)

    return user_db
```

#### 3. **Desarrollo:**

Esta t√©cnica combina el concepto **B** y **C**.
Al hacer `UserInDB(**user_dict, hashed_password=...)`:

1.  Python llena `username` y `email` desde el diccionario `user_dict`.
2.  Python llena `hashed_password` desde el argumento extra que pasaste manualmente.
3.  Si `user_dict` ten√≠a un campo `password` (plana), `UserInDB` simplemente lo ignorar√° si no est√° definido en su clase, o dar√° error si no esperamos argumentos extra (depende de la config), pero lo importante es que **inyectamos** el dato seguro.

üîµ **Espec√≠fico**: Es la forma est√°ndar de "transformar" objetos en el flujo de negocio de FastAPI.

---

## E - Herencia de Modelos: Reduciendo Duplicaci√≥n [üü°]

#### 1. **Introducci√≥n:**

En lugar de repetir `username: str` y `email: str` en tres clases distintas, crea una clase base y hereda de ella.

#### 2. **Ejemplo:**

```python
# 1. La base com√∫n (Padre)
class UserBase(BaseModel):
    username: str
    email: str

# 2. Input (Hijo): Hereda base + a√±ade password
class UserIn(UserBase):
    password: str

# 3. Output (Hijo): Hereda base (y nada m√°s, as√≠ ocultamos password)
class UserOut(UserBase):
    pass

# 4. DB (Hijo): Hereda base + a√±ade hash
class UserInDB(UserBase):
    hashed_password: str
```

#### 3. **Desarrollo:**

Esto es aplicar el principio **DRY (Don't Repeat Yourself)**.

- Si ma√±ana quieres a√±adir un campo `age: int` a todos, solo lo a√±ades en `UserBase`.
- La validaci√≥n, documentaci√≥n y tipos funcionan exactamente igual que si lo escribieras todo tres veces.

üü° **Importante**: Mantiene tu c√≥digo limpio y sincronizado. Evita errores tontos de copiar y pegar.

---

## F - Uniones (`Union`): Respuestas Polim√≥rficas [üîµ]

#### 1. **Introducci√≥n:**

A veces tu API necesita responder con "una cosa O la otra" (ej: un objeto Coche O un objeto Avi√≥n).

#### 2. **Ejemplo:**

```python
from typing import Union

class CarItem(BaseModel):
    type: str = "car"

class PlaneItem(BaseModel):
    type: str = "plane"
    size: int

# La respuesta puede ser Avi√≥n O Coche
@app.get("/items/{id}", response_model=Union[PlaneItem, CarItem])
async def read_item(id: str):
    return items[id]
```

#### 3. **Desarrollo:**

En OpenAPI (Swagger), esto se define como `anyOf`.
**¬°Cuidado con el orden!** ‚ö†Ô∏è
Pydantic intenta validar en orden. Si tienes dos modelos muy parecidos, pon el **m√°s espec√≠fico primero**.
Ejemplo: `Union[PlaneItem, CarItem]`. Si `PlaneItem` es m√°s estricto (tiene m√°s campos obligatorios), ponlo antes. Si pones el gen√©rico primero, podr√≠a validar err√≥neamente un Avi√≥n como un Coche.

üîµ **Espec√≠fico**: √ötil cuando un endpoint es din√°mico.

---

## G - La Trampa de la Sintaxis `Union` en Python 3.10 [üîµ]

#### 1. **Introducci√≥n:**

Aunque Python 3.10 permite escribir `TypeA | TypeB` en lugar de `Union[TypeA, TypeB]`, hay un lugar donde esto falla en FastAPI.

#### 2. **Ejemplo:**

```python
# ‚úÖ En anotaciones de tipo (variables, argumentos):
user: User | None = None  # Funciona perfecto

# ‚ùå En el VALOR del argumento response_model:
# @app.get("/", response_model=User | None)  <-- ERROR en Python

# ‚úÖ Forma correcta para response_model (incluso en 3.10):
@app.get("/", response_model=Union[User, None])
```

#### 3. **Desarrollo:**

¬øPor qu√© pasa esto?
Cuando escribes `response_model=A | B`, Python intenta ejecutar la operaci√≥n "OR" (`|`) entre las clases `A` y `B` en ese mismo instante, lo cual no es v√°lido.
En cambio, cuando lo usas como "type hint" (`user: A | B`), Python sabe que es solo una definici√≥n de tipo.

**Regla de oro**: Dentro de `response_model=...`, usa siempre `Union[...]` para ir a lo seguro.

---

## H - Listas y Diccionarios Arbitrarios [‚ö™]

#### 1. **Introducci√≥n:**

No siempre devuelves un solo objeto. A veces es una lista de ellos, o un diccionario libre sin esquema fijo.

#### 2. **Ejemplo:**

```python
from typing import List, Dict # En Python 3.9+ puedes usar list y dict min√∫sculas

# Lista de objetos
@app.get("/items/", response_model=List[Item])
async def get_items(): ...

# Diccionario libre (claves string, valores float)
@app.get("/weights/", response_model=Dict[str, float])
async def get_weights():
    return {"foo": 2.3, "bar": 5.0}
```

#### 3. **Desarrollo:**

- **Listas**: √ötil para endpoints de "b√∫squeda" o "listar todos".
- **Diccionarios Arbitrarios**: √ötil cuando no sabes qu√© nombres tendr√°n las claves de antemano (ej: pesos de palabras, configuraci√≥n din√°mica), pero s√≠ sabes el tipo de dato.

‚ö™ **Raramente usado (Dicts)**: Usar `Dict` arbitrario pierde la gracia de la validaci√≥n estricta de Pydantic. √ösalo solo cuando realmente no puedas definir un modelo fijo.
