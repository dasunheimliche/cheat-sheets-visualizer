---
title: "1.02 - Concurrencia y Async/Await en FastAPI"
description: "Gu칤a definitiva para entender la asincron칤a, concurrencia vs paralelismo y c칩mo aplicarlo en FastAPI sin morir en el intento."
tags: ["fastapi", "async", "await", "concurrency", "python"]
prompt-version: cheat-sheet-generator-1.1
---

## A - `async def` vs. `def`: La Decisi칩n R치pida en FastAPI 游댮

#### 1. **Introducci칩n:**

Esta es tu regla de oro para decidir si tu funci칩n de endpoint en FastAPI debe empezar con `async def` o simplemente con `def`.

#### 2. **Ejemplo (Gu칤a de decisi칩n):**

- **Usa `async def` si...** llamas a una librer칤a externa que te pide usar `await`.
  ```python
  # La librer칤a "some_library" es as칤ncrona, por eso usamos await.
  @app.get('/')
  async def read_results():
      results = await some_library() # <--- La clave est치 aqu칤
      return results
  ```
- **Usa `def` si...** llamas a una librer칤a que _no_ usa `await` (como la mayor칤a de las librer칤as de bases de datos tradicionales).
  ```python
  # La librer칤a "some_library" es s칤ncrona (normal), no hay await.
  @app.get('/')
  def results():
      results = some_library() # <--- No hay await
      return results
  ```
- **Usa `async def` si...** tu funci칩n no se comunica con nada externo (no espera por nada), pero quieres que se ejecute de forma as칤ncrona.
- **Si tienes dudas...** 춰usa `def`! FastAPI es lo suficientemente inteligente para manejarlo bien.

#### 3. **Desarrollo:**

Piensa en esto como elegir la herramienta correcta para el trabajo. No usas un martillo para atornillar un tornillo, 쯨erdad? Aqu칤 es igual.

- `async def` le dice a FastAPI: "춰Oye! Dentro de esta funci칩n, puede que necesite pausar y esperar a que algo termine (una llamada a una API, una consulta a una base de datos as칤ncrona, etc.). Mientras espero, si칠ntete libre de atender otras peticiones".
- `def` le dice a FastAPI: "Esta funci칩n es de las de toda la vida, secuencial. No sabe c칩mo 'pausar'. Si tiene que hacer algo que tarda, bloquear치 todo. 춰Pero no te preocupes, FastAPI, s칠 que eres listo y me ayudar치s!". (Y como veremos en el concepto **L**, FastAPI es muy listo y lo ejecuta en un "hilo" aparte para no bloquear nada).

La buena noticia es que puedes mezclar y combinar ambas en tu aplicaci칩n sin ning칰n problema. FastAPI se encarga de la magia por debajo.

游댮 **Fundamental**: Esta decisi칩n afecta directamente al rendimiento y al comportamiento de tus endpoints. Entender cu치ndo usar cada uno es una de las primeras y m치s importantes cosas que debes saber al usar FastAPI.

---

## B - C칩digo As칤ncrono: El Arte de "Saber Esperar" 游댮

#### 1. **Introducci칩n:**

El c칩digo as칤ncrono es una forma de decirle a tu programa que, cuando tenga que esperar por una tarea lenta, puede aprovechar ese tiempo para hacer otras cosas.

#### 2. **Ejemplo (Analog칤a):**

Imagina que pones una pizza en el horno (una tarea lenta). En lugar de quedarte mirando el horno durante 20 minutos sin hacer nada (s칤ncrono), pones un temporizador y te vas a poner la mesa, preparar las bebidas y elegir una pel칤cula (hacer otras tareas). Cuando suena el temporizador (la tarea lenta ha terminado), vuelves a por la pizza.

**Explicaci칩n del ejemplo:**
T칰 eres el programa. La pizza en el horno es una "operaci칩n de I/O" (ver concepto **C**). Poner la mesa y preparar las bebidas son otras tareas que puedes hacer mientras esperas. No has hecho las cosas m치s r치pido, pero has aprovechado mejor el tiempo.

#### 3. **Desarrollo:**

La palabra clave es **"esperar"**. El c칩digo as칤ncrono brilla cuando hay esperas inevitables, normalmente relacionadas con operaciones de entrada/salida (I/O) que son lentas en comparaci칩n con la velocidad del procesador. En lugar de que tu programa se quede de brazos cruzados, el sistema operativo le permite cambiar de contexto y trabajar en otra tarea pendiente. Una vez que la operaci칩n lenta termina, el programa puede volver a ella y continuar donde lo dej칩. Esto hace que tu aplicaci칩n sea mucho m치s eficiente y pueda manejar a muchos m치s usuarios a la vez.

游댮 **Fundamental**: Este es el concepto central sobre el que se construye FastAPI y muchos frameworks web modernos. Entenderlo es clave para escribir aplicaciones r치pidas y escalables.

---

## C - Operaciones "I/O Bound": 쯇or Qu칠 Esperamos? 游리

#### 1. **Introducci칩n:**

Una operaci칩n "I/O Bound" (limitada por Entrada/Salida) es cualquier tarea donde el programa pasa la mayor parte del tiempo esperando una respuesta de un recurso externo, en lugar de hacer c치lculos.

#### 2. **Ejemplo (Lista de culpables comunes):**

- Esperar datos de un cliente a trav칠s de la red.
- Leer o escribir un archivo en el disco duro.
- Hacer una petici칩n a otra API.
- Esperar que una base de datos devuelva los resultados de una consulta.

#### 3. **Desarrollo:**

Piensa en la velocidad de tu CPU como un superh칠roe que puede hacer miles de millones de c치lculos por segundo. Ahora, imagina que ese superh칠roe tiene que pedirle un dato a una tortuga (el disco duro o la red). El superh칠roe podr칤a pasarse una eternidad (en su escala de tiempo) esperando a que la tortuga vuelva.

Estas tareas se llaman "I/O Bound" porque el "cuello de botella", lo que las hace lentas, no es el poder de c치lculo de la CPU, sino el tiempo de espera de la operaci칩n de Entrada/Salida (Input/Output). El c칩digo as칤ncrono (ver concepto **B**) es la soluci칩n perfecta para estos escenarios.

游리 **Importante**: Saber identificar si tu c칩digo es "I/O Bound" te ayuda a decidir si necesitas usar `async def` (ver concepto **A**). La mayor칤a de las aplicaciones web son, en gran medida, "I/O Bound".

---

## D - Concurrencia vs. Paralelismo: La Gran Diferencia 游댮

#### 1. **Introducci칩n:**

Aunque ambos conceptos suenan a "hacer muchas cosas a la vez", describen dos formas muy diferentes de lograrlo.

#### 2. **Ejemplo (Definici칩n simple):**

- **Concurrencia:** Un solo trabajador (ej: un cocinero) es capaz de gestionar m칰ltiples tareas (varios pedidos) alternando su atenci칩n entre ellas. Empieza una, la deja en pausa mientras espera algo, y empieza otra.
- **Paralelismo:** M칰ltiples trabajadores (ej: varios cocineros) ejecutan tareas diferentes al mismo tiempo, cada uno enfocado en la suya.

#### 3. **Desarrollo:**

Esta es una de las confusiones m치s comunes. 춰Vamos a dejarlo meridianamente claro!

- La **concurrencia** se trata de **gestionar** m칰ltiples tareas. Es una cuesti칩n de estructura y de c칩mo se manejan las pausas. Imagina un malabarista con 5 pelotas (las tareas). Solo tiene dos manos (el procesador), as칤 que no puede tocar todas las pelotas a la vez. Pero al lanzarlas y atraparlas en el momento justo, da la ilusi칩n de que todas est치n en movimiento simult치neamente.
- El **paralelismo** se trata de **ejecutar** m칰ltiples tareas. Requiere hardware que lo soporte (m칰ltiples n칰cleos de CPU). Es como tener 5 malabaristas, cada uno con su propia pelota. Est치n haciendo el trabajo de verdad, al mismo tiempo.

Una aplicaci칩n puede ser concurrente sin ser paralela (un solo n칰cleo de CPU cambiando entre tareas), pero no al rev칠s.

游댮 **Fundamental**: Entender esta diferencia es crucial para dise침ar sistemas eficientes. La concurrencia es ideal para problemas "I/O Bound" (ver **C**), mientras que el paralelismo es para problemas "CPU Bound" (ver **H**).

---

## E - Concurrencia: El Cocinero de Hamburguesas Eficiente 游리

#### 1. **Introducci칩n:**

Esta analog칤a ilustra perfectamente c칩mo funciona la concurrencia en una aplicaci칩n web para no perder el tiempo mientras se espera.

#### 2. **Ejemplo (La historia):**

1.  **Pides 2 hamburguesas** en el mostrador. El cajero toma tu orden.
    ![Pidiendo hamburguesas](https://fastapi.tiangolo.com/img/async/concurrent-burgers/concurrent-burgers-02.png)
2.  **El cajero avisa al cocinero** y te da un n칰mero. Tu tarea con el cajero est치 "en pausa".
    ![Recibiendo un n칰mero](https://fastapi.tiangolo.com/img/async/concurrent-burgers/concurrent-burgers-04.png)
3.  **Mientras esperas**, no te quedas parado en el mostrador. Te vas a una mesa y charlas con tu pareja. Est치s "haciendo otra tarea".
    ![Esperando en la mesa](https://fastapi.tiangolo.com/img/async/concurrent-burgers/concurrent-burgers-05.png)
4.  **Tu n칰mero aparece en pantalla**. Terminas tu conversaci칩n, vas al mostrador, recoges las hamburguesas y vuelves. Has "retomado y finalizado" la tarea original.
    ![Recogiendo las hamburguesas](https://fastapi.tiangolo.com/img/async/concurrent-burgers/concurrent-burgers-06.png)

#### 3. **Desarrollo:**

En esta historia, **t칰 eres el programa (o el hilo de ejecuci칩n)**.

- **La espera por las hamburguesas** es la operaci칩n "I/O Bound".
- **El cajero y el cocinero** son el sistema que gestiona las tareas.
- **Ir a la mesa y charlar** es el programa aprovechando el tiempo de espera para atender otra petici칩n/tarea.

La clave es que **un solo trabajador (t칰) pudo gestionar m칰ltiples actividades (pedir, esperar, charlar, recoger) de forma eficiente** porque no se qued칩 bloqueado esperando. Esto es exactamente lo que hace un servidor web as칤ncrono como FastAPI.

游리 **Importante**: Esta analog칤a es la forma m치s intuitiva de entender por qu칠 la asincron칤a y la concurrencia son tan potentes para el desarrollo web.

---

## F - Paralelismo: Muchos Cocineros, Una Larga Fila 游리

#### 1. **Introducci칩n:**

Esta es la contraparte de la historia anterior, mostrando un sistema que usa paralelismo pero que puede no ser el m치s eficiente para este tipo de problema.

#### 2. **Ejemplo (La historia):**

1.  Hay **8 cajeros que tambi칠n son cocineros**. Cada uno atiende a un cliente de principio a fin.
    ![M칰ltiples cajeros](https://fastapi.tiangolo.com/img/async/parallel-burgers/parallel-burgers-01.png)
2.  **Pides tus 2 hamburguesas**. El cajero/cocinero se va a la cocina a prepararlas.
    ![Cajero va a la cocina](https://fastapi.tiangolo.com/img/async/parallel-burgers/parallel-burgers-02.png)
3.  **Tienes que esperar parado en el mostrador**. No puedes irte a una mesa porque no hay sistema de turnos. Si te mueves, otro podr칤a llevarse tu pedido. Est치s "bloqueado".
    ![Esperando en el mostrador](https://fastapi.tiangolo.com/img/async/parallel-burgers/parallel-burgers-03.png)
4.  **Despu칠s de una larga espera**, el cajero/cocinero vuelve con tu comida. La recoges y te vas.
    ![Recibiendo las hamburguesas](https://fastapi.tiangolo.com/img/async/parallel-burgers/parallel-burgers-05.png)

#### 3. **Desarrollo:**

En esta historia, hay **m칰ltiples trabajadores (los 8 cajeros/cocineros) trabajando en paralelo**. Sin embargo, el sistema es **s칤ncrono** para cada cliente. T칰, como cliente, est치s "sincronizado" con tu cajero, esperando sin poder hacer nada m치s.

Aunque el restaurante tiene m치s "potencia de procesamiento" (8 cocineros vs. 1), la experiencia para ti no es mejor porque el proceso te obliga a esperar de forma ineficiente. Esto demuestra que el paralelismo no siempre es la mejor soluci칩n, especialmente cuando hay muchas esperas involucradas.

游리 **Importante**: Entender este contraejemplo solidifica tu comprensi칩n de por qu칠 la concurrencia es a menudo preferible al paralelismo en el desarrollo web.

---

## G - Conclusi칩n de las Hamburguesas: 쮺u치ndo es Mejor la Concurrencia? 游리

#### 1. **Introducci칩n:**

La concurrencia no es inherentemente mejor que el paralelismo; es simplemente la herramienta adecuada para problemas con mucha espera.

#### 2. **Ejemplo:**

- **Escenario ideal para Concurrencia:** Una aplicaci칩n web que atiende a miles de usuarios con conexiones lentas. El servidor pasa la mayor parte del tiempo esperando que lleguen las peticiones y que se env칤en las respuestas.
- **Escenario ideal para Paralelismo:** Procesar un video. No hay esperas, solo una cantidad masiva de c치lculos que se pueden dividir entre m칰ltiples procesadores.

#### 3. **Desarrollo:**

La moraleja de las hamburguesas es que, para las aplicaciones web, el modelo concurrente (un cocinero que gestiona m칰ltiples pedidos) es mucho m치s eficiente. La mayor parte del tiempo, un servidor web no est치 calculando cosas, sino **esperando**: esperando la petici칩n del usuario, esperando la respuesta de la base de datos, esperando que el usuario reciba la respuesta.

La concurrencia permite que el servidor use esos microsegundos de espera para atender a otros cientos o miles de usuarios, haciendo que todo el sistema sea incre칤blemente r치pido y receptivo. Esto es lo que hizo popular a NodeJS y es la misma superpotencia que tiene FastAPI.

游리 **Importante**: Este concepto te ayuda a conectar la teor칤a (concurrencia) con la pr치ctica (desarrollo web) y a entender por qu칠 frameworks como FastAPI est치n dise침ados de esta manera.

---

## H - Operaciones "CPU Bound": Cuando el Trabajo es Intenso, no la Espera 游댯

#### 1. **Introducci칩n:**

Una operaci칩n "CPU Bound" (limitada por CPU) es una tarea donde el tiempo de ejecuci칩n est치 determinado por la velocidad del procesador, ya que implica c치lculos intensivos sin esperas.

#### 2. **Ejemplo (Lista de tareas intensivas):**

- Procesamiento de audio o im치genes (aplicar filtros, cambiar tama침o).
- Visi칩n por computadora (analizar los p칤xeles de una imagen).
- Machine Learning (multiplicar matrices enormes).
- Limpiar una casa muy grande: no hay que esperar a nada, solo hay mucho trabajo f칤sico que hacer.

#### 3. **Desarrollo:**

A diferencia de las tareas "I/O Bound" (ver concepto **C**), aqu칤 no hay "tiempos muertos". La CPU est치 trabajando al 100% todo el rato. En estos casos, la concurrencia (un solo trabajador cambiando de tarea) no ofrece ninguna ventaja. De hecho, podr칤a ser hasta un poco m치s lento por el coste de cambiar de contexto.

Para estas tareas, el **paralelismo** es el rey. Si tienes que limpiar una casa grande (tarea "CPU Bound"), traer a 8 amigos (8 n칰cleos de CPU) para que cada uno limpie una habitaci칩n har치 que termines 8 veces m치s r치pido.

游댯 **Espec칤fico**: Es bueno saber que existe este tipo de problema para entender por qu칠 la asincron칤a no es una soluci칩n m치gica para todo. Si tu aplicaci칩n realiza este tipo de c치lculos, necesitar치s una estrategia de paralelismo, no solo de concurrencia.

---

## I - FastAPI: Lo Mejor de Dos Mundos (Concurrencia + Paralelismo) 游리

#### 1. **Introducci칩n:**

FastAPI te permite aprovechar la concurrencia para las operaciones web t칤picas y, al mismo tiempo, explotar el paralelismo para las tareas pesadas de CPU.

#### 2. **Ejemplo (C칩mo lo logra):**

- **Concurrencia:** Usando `async def` en tus endpoints, FastAPI maneja miles de conexiones de red y esperas de I/O de forma s칰per eficiente, como en la hamburgueser칤a concurrente.
- **Paralelismo:** Al desplegar tu aplicaci칩n con un servidor como Gunicorn y m칰ltiples "workers", est치s ejecutando varias instancias de tu app en paralelo. Cada "worker" es un proceso separado que puede usar un n칰cleo de CPU diferente.

#### 3. **Desarrollo:**

Esta es una de las grandes ventajas de FastAPI en el ecosistema de Python. Combina la eficiencia de I/O de la concurrencia (similar a NodeJS) con la capacidad de Python para realizar c치lculos pesados y aprovechar m칰ltiples n칰cleos de CPU (paralelismo).

Esto lo convierte en una opci칩n ideal para APIs de Machine Learning:

1.  El endpoint recibe una petici칩n (ej: una imagen para analizar) de forma **concurrente** y eficiente.
2.  El modelo de Machine Learning procesa la imagen, una tarea **"CPU Bound"**. Si tienes m칰ltiples workers, puedes procesar varias im치genes en **paralelo**.
3.  El resultado se devuelve al usuario, de nuevo, de forma **concurrente**.

游리 **Importante**: Entender que FastAPI te da acceso a ambas estrategias te permite dise침ar aplicaciones mucho m치s robustas y potentes, especialmente en campos como Data Science y Machine Learning.

---

## J - `async` y `await`: Las Palabras M치gicas de la Asincron칤a 游댮

#### 1. **Introducci칩n:**

`async` y `await` son las palabras clave de Python que te permiten escribir c칩digo as칤ncrono que se lee casi igual que el c칩digo s칤ncrono normal.

#### 2. **Ejemplo:**

```python
# 1. 'async def' marca esta funci칩n como una "coroutine".
#    Sabe que puede ser pausada y reanudada.
async def fetch_data_from_api():
    print("Iniciando la petici칩n a la API...")
    # 2. 'await' le dice a Python: "Pausa la ejecuci칩n de ESTA funci칩n aqu칤".
    #    "Mientras esperas a que 'some_api_call()' termine,
    #    ve y haz otro trabajo que tengas pendiente".
    result = await some_api_call()
    print("춰La API ha respondido!")
    return result

# Para llamar a una funci칩n async, necesitas usar await desde otra funci칩n async.
async def main():
    data = await fetch_data_from_api()
    print(f"Datos recibidos: {data}")
```

**Explicaci칩n del ejemplo:**
Sin `async`/`await`, tendr칤as que usar callbacks o mecanismos m치s complejos. Con ellas, el c칩digo sigue una l칩gica lineal y f치cil de leer. `async def` define una funci칩n "pausable", y `await` es el punto exacto donde le dices "ok, aqu칤 puedes pausar".

#### 3. **Desarrollo:**

- **`async def`**: Es como ponerle una etiqueta especial a una funci칩n. Le dices a Python: "Esta funci칩n no es como las dem치s. Dentro de ella, podemos tener pausas. Cuando la llames, no se ejecutar치 inmediatamente, sino que te devolver치 un objeto especial llamado 'coroutine' (ver concepto **K**)".
- **`await`**: Solo se puede usar dentro de una funci칩n `async def`. Es la se침al de pausa. Le dice al bucle de eventos (el gestor de tareas de Python): "Voy a esperar a que esto termine. T칩mate tu tiempo, yo te aviso. Mientras tanto, si tienes otra cosa que hacer, adelante".

La regla de oro es: si una funci칩n se define con `async def`, para obtener su resultado debes llamarla con `await`. Y para usar `await`, debes estar dentro de otra funci칩n `async def`. FastAPI se encarga de la primera llamada `async` por ti en los endpoints.

游댮 **Fundamental**: Estas dos palabras clave son la sintaxis central para trabajar con c칩digo as칤ncrono en Python moderno. Dominarlas es indispensable.

---

## K - Coroutines: El "Paquete" que Devuelve una Funci칩n `async def` 游댯

#### 1. **Introducci칩n:**

Una "coroutine" es simplemente el nombre t칠cnico del objeto especial que devuelve una funci칩n `async def` cuando la llamas.

#### 2. **Ejemplo:**

```python
async def my_async_function():
    return "춰Hola, mundo as칤ncrono!"

# Si llamas a la funci칩n SIN await...
coroutine_object = my_async_function()
print(coroutine_object)
# Salida: <coroutine object my_async_function at 0x10e7a4f28>
# 춰NO obtienes el string "춰Hola, mundo as칤ncrono!"!

# Para "abrir" el paquete y obtener el resultado, necesitas await:
async def main():
    result = await my_async_function()
    print(result)
    # Salida: 춰Hola, mundo as칤ncrono!
```

#### 3. **Desarrollo:**

Piensa en una coroutine como una receta de cocina. Llamar a la funci칩n `async def` (`my_async_function()`) no te da el pastel terminado, te da la receta (`coroutine_object`). Para obtener el pastel, necesitas un cocinero (el bucle de eventos de Python) que siga la receta. La palabra `await` es la instrucci칩n que le dice al cocinero: "춰Oye, cocina esto!".

Es un objeto que contiene todo lo necesario para ejecutar la funci칩n: el c칩digo, d칩nde se qued칩 la 칰ltima vez que se paus칩, etc. No necesitas interactuar directamente con el objeto coroutine la mayor parte del tiempo, solo recordar que para "ejecutarlo" y obtener su valor de retorno, debes usar `await`.

游댯 **Espec칤fico**: Es un t칠rmino t칠cnico. Aunque no necesitas entender sus detalles internos para ser productivo, saber qu칠 es una "coroutine" te ayudar치 a comprender mejor los mensajes de error y la documentaci칩n t칠cnica.

---

## L - El "Detr치s de C치maras" de FastAPI: C칩mo Maneja `def` y `async def` 游댯

#### 1. **Introducci칩n:**

FastAPI es inteligente y trata las funciones `def` y `async def` de manera diferente para garantizar que tu servidor nunca se bloquee.

#### 2. **Ejemplo (El mecanismo):**

- **Cuando usas `async def`:**

  ```python
  @app.get("/")
  async def root():
      return {"message": "Hola"}
  ```

  FastAPI ejecuta la funci칩n directamente, permitiendo que el bucle de eventos la pause y reanude en los `await`. Es la forma m치s eficiente.

- **Cuando usas `def`:**
  ```python
  @app.get("/items/{item_id}")
  def read_item(item_id: int):
      # Imagina que esto es una llamada a una base de datos antigua y lenta.
      time.sleep(5) # Simula una operaci칩n bloqueante.
      return {"item_id": item_id}
  ```
  FastAPI sabe que esta funci칩n es "bloqueante". Si la ejecutara directamente, todo el servidor se congelar칤a durante 5 segundos. Para evitarlo, la ejecuta en un **"thread pool"** (un grupo de hilos de ejecuci칩n externos). As칤, la funci칩n bloqueante se ejecuta en su propio hilo, sin congelar el hilo principal que atiende a otros usuarios.

#### 3. **Desarrollo:**

Esta es la magia de FastAPI. Te da la libertad de usar c칩digo s칤ncrono "antiguo" (bloqueante) sin penalizar el rendimiento de toda tu aplicaci칩n.

**춰Anticipando una confusi칩n com칰n!** Podr칤as pensar: "Ah, entonces si quiero un peque침o aumento de rendimiento para una funci칩n simple que no hace I/O, uso `def`". **춰Error!** En FastAPI, es al rev칠s. Enviar una funci칩n a un thread pool tiene un peque침o coste de gesti칩n. Por lo tanto, si tu funci칩n no realiza I/O bloqueante, es siempre mejor declararla con `async def`, incluso si no contiene la palabra `await`.

Usa `def` solo cuando **debes** usar una librer칤a que realiza I/O bloqueante (como una librer칤a de base de datos s칤ncrona).

游댯 **Espec칤fico**: Este es un detalle t칠cnico avanzado, pero crucial para entender el rendimiento de FastAPI y para tomar decisiones informadas al escribir tus endpoints. Te convierte de un usuario de FastAPI a un usuario experto.

---

## M - Dependencias y Sub-dependencias: La Misma L칩gica As칤ncrona 游리

#### 1. **Introducci칩n:**

La misma l칩gica que se aplica a los endpoints (`async def` vs. `def`) se aplica exactamente igual a las funciones de dependencia de FastAPI.

#### 2. **Ejemplo:**

```python
# Dependencia s칤ncrona (bloqueante)
def get_user_from_db(user_id: int):
    # ...c칩digo que habla con una DB s칤ncrona...
    return user

# Dependencia as칤ncrona
async def get_user_permissions(user: User = Depends(get_user_from_db)):
    # ...c칩digo que llama a una API externa con await...
    permissions = await some_api.get_permissions(user.id)
    return permissions

@app.get("/users/{user_id}")
async def read_user(permissions: list = Depends(get_user_permissions)):
    return {"permissions": permissions}
```

**Explicaci칩n del ejemplo:**
FastAPI ve que `get_user_from_db` es una funci칩n `def` y la ejecutar치 en el thread pool. Luego, "inyectar치" su resultado en `get_user_permissions`, que es una funci칩n `async def` y se ejecutar치 normalmente. FastAPI gestiona toda esta orquestaci칩n por ti.

#### 3. **Desarrollo:**

No importa cu치n anidadas est칠n tus dependencias, FastAPI aplicar치 la regla consistentemente:

- Si es `async def`, la "espera" (`await`).
- Si es `def`, la env칤a a un thread pool para no bloquear el bucle principal.

Esto te da una flexibilidad enorme para mezclar y combinar librer칤as nuevas (as칤ncronas) y antiguas (s칤ncronas) en tu sistema de dependencias sin tener que preocuparte por los detalles de la ejecuci칩n.

游리 **Importante**: Las dependencias son una caracter칤stica central de FastAPI. Entender c칩mo interact칰an con la asincron칤a es clave para construir aplicaciones complejas y eficientes.

---

## N - Funciones de Utilidad: Tu C칩digo, Tus Reglas 游댯

#### 1. **Introducci칩n:**

Para cualquier otra funci칩n que t칰 llames directamente desde tu c칩digo (que no sea un endpoint o una dependencia), FastAPI no interviene; t칰 tienes el control total.

#### 2. **Ejemplo:**

```python
# Una funci칩n de utilidad s칤ncrona
def format_data(data: dict) -> str:
    # ...hace alg칰n c치lculo r치pido...
    return f"Formatted: {data}"

# Una funci칩n de utilidad as칤ncrona
async def log_to_external_service(message: str):
    # ...env칤a un log a un servicio externo...
    await some_logging_service.log(message)

@app.get("/")
async def main_endpoint():
    raw_data = {"key": "value"}

    # 1. Llamas a la funci칩n 'def' directamente.
    #    No va a un thread pool porque no es una dependencia.
    formatted = format_data(raw_data)

    # 2. Llamas a la funci칩n 'async def' con 'await'.
    #    T칰 eres responsable de usar await.
    await log_to_external_service(formatted)

    return {"status": "done"}
```

#### 3. **Desarrollo:**

La distinci칩n es crucial: la magia del "thread pool" de FastAPI para funciones `def` solo se aplica a las funciones que **FastAPI llama por ti**, es decir, los _path operation functions_ (endpoints) y las dependencias.

Si tienes una funci칩n de utilidad `def` que es bloqueante y la llamas directamente desde tu endpoint, **S칈 bloquear치s el servidor**. En ese caso, ser칤as t칰 el responsable de ejecutarla en un thread pool si fuera necesario (usando librer칤as como `anyio` o `asyncio`).

En resumen:

- **Endpoints y Dependencias:** FastAPI gestiona `def` vs `async def`.
- **Tus propias funciones:** T칰 gestionas `def` vs `async def`. Si es `async`, debes usar `await`. Si es `def` bloqueante, ten cuidado.

游댯 **Espec칤fico**: Este es un detalle sutil pero importante para evitar cuellos de botella de rendimiento accidentales. Aclara los l칤mites de la "magia" de FastAPI y te recuerda que sigues teniendo el control (y la responsabilidad) sobre tu propio c칩digo.
