---
title: "7 - Entrada y Salida de Datos (I/O) en Python"
description: "Gu칤a definitiva para formatear texto, manipular archivos y serializar datos con JSON"
tags: ["python", "io", "files", "json", "formatting"]
prompt-version: cheat-sheet-generator-1.1
---

## A - F-Strings: La forma moderna de formatear texto [游댮]

#### 1. **Introducci칩n:**

Es la forma m치s nueva, r치pida y legible de incrustar variables dentro de cadenas de texto, simplemente poniendo una `f` antes de las comillas.

#### 2. **Ejemplo:**

```python
nombre = "Python"
version = 3.14159

# 1. B치sico: Variables directas
print(f"Hola, estoy aprendiendo {nombre}")
# Salida: Hola, estoy aprendiendo Python

# 2. Con formato (redondear decimales)
print(f"La versi칩n aproximada es {version:.2f}")
# Salida: La versi칩n aproximada es 3.14

# 3. Depuraci칩n r치pida (el signo = imprime nombre y valor)
bugs = "hormigas"
print(f"Debugging: {bugs=}")
# Salida: Debugging: bugs='hormigas'
```

**Explicaci칩n del ejemplo:**
Usamos `{}` para meter c칩digo Python dentro del texto. El `.2f` le dice a Python "quiero esto como un n칰mero flotante con 2 decimales". El `=` es un truco m치gico para no tener que escribir `print("x =", x)`, Python lo hace solo.

#### 3. **Desarrollo:**

Las **Formatted String Literals** (f-strings) permiten ejecutar expresiones Python dentro de las llaves. Puedes sumar n칰meros, llamar funciones o formatear la salida (como alinear columnas o rellenar con ceros) directamente en la cadena.

游댮 **Fundamental:** Es el est치ndar actual de la industria. Si est치s aprendiendo Python hoy, esta es la herramienta que usar치s el 99% del tiempo para mostrar texto.

---

## B - El m칠todo `str.format()`: El hermano mayor [游리]

#### 1. **Introducci칩n:**

Es la forma de formatear texto anterior a las f-strings; separa el texto de los datos, lo cual es 칰til si reutilizas la misma plantilla de texto con diferentes datos.

#### 2. **Ejemplo:**

```python
# Usando posiciones (0, 1, 2...)
print("Soy {0} y me gusta {1}".format("Juan", "programar"))

# Usando nombres (m치s claro)
print("Hola {nombre}, tienes {puntos} puntos".format(nombre="Ana", puntos=100))

# Desempaquetando un diccionario (Truco Avanzado)
datos = {'personaje': 'Mario', 'vidas': 3}
print("Jugador: {personaje}, Vidas: {vidas}".format(**datos))
```

#### 3. **Desarrollo:**

Aunque las f-strings son preferidas, `format()` sigue siendo muy 칰til cuando la cadena de texto la recibes desde fuera (por ejemplo, una traducci칩n en un archivo de texto) y necesitas "rellenarla" con variables despu칠s.

游리 **Importante:** Lo ver치s mucho en c칩digo escrito antes de Python 3.6 y es necesario conocerlo para mantener sistemas existentes o trabajar con plantillas externas.

---

## C - `str()` vs `repr()`: 쯇ara qui칠n es el mensaje? [游리]

#### 1. **Introducci칩n:**

`str()` convierte un objeto a texto para que lo lea un **humano**; `repr()` lo convierte a texto para que lo lea el **int칠rprete** (o un desarrollador depurando).

#### 2. **Ejemplo:**

```python
texto = "Hola\nMundo"

# str(): Se ve bonito, interpreta el salto de l칤nea
print(str(texto))
# Salida:
# Hola
# Mundo

# repr(): Muestra las "tripas", incluye comillas y caracteres especiales
print(repr(texto))
# Salida: 'Hola\nMundo'
```

#### 3. **Desarrollo:**

Aqu칤 es donde muchos aprendices se confunden.

- **`str()`**: Busca legibilidad. Si conviertes una fecha, te dir치 "2023-10-25".
- **`repr()`**: Busca **no ambig칲edad**. Si conviertes esa misma fecha, te dir치 `datetime.date(2023, 10, 25)`. El objetivo de `repr()` es que, si copias y pegas su salida en el c칩digo, deber칤as poder recrear el objeto.

**COMPARACI칍N CLAVE:**
Usa `str()` para mostrar mensajes al usuario final. Usa `repr()` (o el modificador `!r` en f-strings) cuando est칠s buscando errores y necesites saber _exactamente_ qu칠 hay en la variable (쯘s un n칰mero o un string? 쯦iene espacios ocultos?).

游리 **Importante:** Entender esto te ahorrar치 horas cuando intentes descubrir por qu칠 tu string no es igual a otro aunque "se vean iguales".

---

## D - Formateo Manual y Antiguo [游댯]

#### 1. **Introducci칩n:**

M칠todos para alinear texto "a mano" o usar el operador `%` (estilo antiguo de C).

#### 2. **Ejemplo:**

```python
# Manual: Rellenar con espacios o ceros
print("12".zfill(5))        # Salida: 00012
print("Hola".center(10))    # Salida:    Hola

# Antiguo (%): Estilo printf
import math
print("Pi es aprox %5.3f" % math.pi) # Salida: Pi es aprox 3.142
```

#### 3. **Desarrollo:**

- **Manual (`rjust`, `ljust`, `zfill`):** 칔tiles para generar tablas de texto simples sin usar librer칤as complejas.
- **Antiguo (`%`):** Se mantiene por compatibilidad, pero es menos flexible que las f-strings.

游댯 **Espec칤fico:** 칔salo solo si necesitas mantener c칩digo muy viejo o hacer alineaciones muy simples sin l칩gica compleja.

---

## E - `open()` y Modos de Archivo: La puerta de entrada [游댮]

#### 1. **Introducci칩n:**

La funci칩n `open()` conecta tu programa con un archivo en el disco. El "modo" en que lo abres define qu칠 puedes hacer (y qu칠 peligros corres).

#### 2. **Ejemplo:**

```python
# Sintaxis: open(nombre_archivo, modo, encoding)

# 'r' = Read (Leer). Falla si no existe.
f = open('nota.txt', 'r', encoding='utf-8')

# 'w' = Write (Escribir). 춰PELIGRO! Borra el contenido anterior.
f = open('nota.txt', 'w', encoding='utf-8')

# 'a' = Append (A침adir). Escribe al final sin borrar.
f = open('nota.txt', 'a', encoding='utf-8')
```

#### 3. **Desarrollo:**

Es vital especificar el `encoding='utf-8'` en modo texto para evitar problemas con tildes o emojis, ya que el valor por defecto cambia seg칰n tu sistema operativo (Windows vs Linux).
Si a침ades una `b` al modo (ej: `'rb'`, `'wb'`), abres el archivo en **modo binario** (para im치genes, PDFs, etc.), donde lees/escribes `bytes` en lugar de `strings`.

游댮 **Fundamental:** Equivocarse de modo (usar `'w'` en vez de `'r'`) puede destruir datos. Memoriza: `'w'` de "Wipe" (Borrar/Escribir).

---

## F - La sentencia `with`: Tu red de seguridad [游댮]

#### 1. **Introducci칩n:**

Es la forma correcta y segura de abrir archivos. Se encarga de cerrar el archivo autom치ticamente, incluso si tu programa falla a la mitad.

#### 2. **Ejemplo:**

```python
# FORMA CORRECTA (Usando with)
with open('archivo.txt', 'r', encoding='utf-8') as f:
    contenido = f.read()
    # Aqu칤 el archivo est치 abierto
# Aqu칤 el archivo YA se cerr칩 autom치ticamente. Magia.

# FORMA INCORRECTA (O arriesgada)
f = open('archivo.txt', 'r')
contenido = f.read()
f.close() # Si f.read() falla, esta l칤nea nunca se ejecuta y el archivo queda "colgado".
```

#### 3. **Desarrollo:**

Cuando abres un archivo, consumes recursos del sistema. Si olvidas cerrarlo (o si un error impide que llegues a la l칤nea `close()`), puedes bloquear el archivo o perder datos que no se terminaron de escribir. `with` es un "Context Manager" que garantiza la limpieza.

游댮 **Fundamental:** Nunca uses `open()` sin `with` a menos que tengas una raz칩n extremadamente espec칤fica y avanzada.

---

## G - Lectura de Archivos: 쯊odo o l칤nea por l칤nea? [游리]

#### 1. **Introducci칩n:**

Puedes leer el archivo entero de golpe o procesarlo l칤nea por l칤nea para ahorrar memoria.

#### 2. **Ejemplo:**

```python
with open('datos.txt', 'r') as f:

    # Opci칩n A: Leer TODO a la memoria (Cuidado con archivos gigantes)
    # texto_completo = f.read()

    # Opci칩n B: Leer l칤nea por l칤nea (Eficiente y Pythonico)
    for linea in f:
        print(linea, end='') # end='' porque la linea ya trae su propio salto (\n)
```

#### 3. **Desarrollo:**

- `f.read(size)`: Lee una cantidad espec칤fica o todo si no pones nada.
- `f.readline()`: Lee una sola l칤nea. Devuelve `''` (vac칤o) solo al final del archivo.
- `for line in f`: Es la mejor opci칩n. Python maneja la memoria inteligentemente, cargando y descartando l칤neas a medida que las necesitas.

游리 **Importante:** Iterar sobre el objeto archivo (`for line in f`) es la pr치ctica est치ndar en Python.

---

## H - Escritura y Navegaci칩n (`write`, `seek`, `tell`) [游댯]

#### 1. **Introducci칩n:**

Para escribir debes convertir todo a texto primero. Adem치s, los archivos funcionan como una cinta de casete: tienen un cabezal que puedes mover.

#### 2. **Ejemplo:**

```python
with open('salida.txt', 'w', encoding='utf-8') as f:
    valor = 42
    # f.write(valor)  <-- ERROR: write solo acepta strings
    f.write(str(valor)) # Correcto
    f.write("\n")       # Debes poner tus propios saltos de l칤nea

    print(f.tell())     # Te dice en qu칠 byte est치 el cursor
    f.seek(0)           # Mueve el cursor al inicio del archivo
```

#### 3. **Desarrollo:**

A diferencia de `print()`, `f.write()` no agrega espacios ni saltos de l칤nea autom치ticamente; tienes que ser expl칤cito.
`seek(offset, whence)` permite moverte por el archivo (칰til en binarios), pero en archivos de texto es complejo y restringido.

游댯 **Espec칤fico:** La mayor칤a de las veces escribir치s secuencialmente. `seek` y `tell` son herramientas de precisi칩n para casos puntuales.

---

## I - JSON: Guardando datos estructurados [游리]

#### 1. **Introducci칩n:**

Guardar listas o diccionarios en un archivo de texto plano es dif칤cil de leer despu칠s. JSON es un formato est치ndar que permite guardar estas estructuras complejas como texto y recuperarlas igual.

#### 2. **Ejemplo:**

```python
import json

datos = [1, "simple", {"clave": "valor"}]

# 1. Serializar (Python -> String JSON)
json_string = json.dumps(datos)
# Resultado: '[1, "simple", {"clave": "valor"}]'

# 2. Guardar en archivo (Python -> Archivo)
with open('datos.json', 'w', encoding='utf-8') as f:
    json.dump(datos, f)

# 3. Recuperar de archivo (Archivo -> Python)
with open('datos.json', 'r', encoding='utf-8') as f:
    datos_recuperados = json.load(f)
```

#### 3. **Desarrollo:**

- **Serializar**: Convertir objetos vivos de Python a una cadena de texto (JSON).
- **Deserializar**: Reconstruir los objetos Python a partir del texto.
- `dump`/`load`: Trabajan directamente con **archivos**.
- `dumps`/`loads`: Trabajan con **strings** (la 's' es de string).

游리 **Importante:** JSON es el lenguaje universal para intercambiar datos entre aplicaciones (web, APIs, config).

---

## J - JSON vs Pickle: La trampa de seguridad [游댯]

#### 1. **Introducci칩n:**

Python tiene dos formas de guardar objetos: `json` (texto, seguro, universal) y `pickle` (binario, espec칤fico de Python, potente pero peligroso).

#### 2. **Comparaci칩n Paranoica:**

| Caracter칤stica     | JSON (`json`)                     | Pickle (`pickle`)                     |
| :----------------- | :-------------------------------- | :------------------------------------ |
| **Legibilidad**    | Humano (Texto)                    | M치quina (Binario)                     |
| **Compatibilidad** | Universal (Java, JS, C++ lo leen) | Solo Python                           |
| **Capacidad**      | Listas, dicts, nums, strings      | Casi cualquier objeto Python complejo |
| **Seguridad**      | **Seguro**                        | **INSECURO** 驕멆잺                       |

#### 3. **Desarrollo:**

**쯇or qu칠 Pickle es inseguro?**
Al deserializar un archivo `pickle`, Python puede ejecutar c칩digo arbitrario. Si alguien te env칤a un archivo `pickle` malicioso y lo abres con `pickle.load()`, podr칤an hackear tu computadora.

**Regla de Oro:**
Usa **JSON** por defecto. Usa **Pickle** SOLO si conf칤as al 100% en la fuente del archivo (ej: un archivo temporal que tu propio programa cre칩 hace 5 minutos) y necesitas guardar objetos muy complejos que JSON no soporta.

游댯 **Espec칤fico:** Conoce Pickle por si lo ves, pero prefiere JSON.
