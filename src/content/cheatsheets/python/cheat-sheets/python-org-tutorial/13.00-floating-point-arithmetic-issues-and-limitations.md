---
title: "15.1 - AritmÃ©tica de Punto Flotante en Python"
description: "Por quÃ© tus nÃºmeros decimales a veces se comportan de forma extraÃ±a y cÃ³mo manejarlo sin perder la cabeza."
tags: ["python", "math", "floats", "precision"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Naturaleza de los Floats: Binario vs. Decimal [ğŸ”´]

#### 1. **IntroducciÃ³n:**

Las computadoras no piensan en base 10 (decimal) como nosotros, sino en base 2 (binario); esto causa problemas de traducciÃ³n al guardar fracciones.

#### 2. **Ejemplo:**

```python
# FracciÃ³n Decimal (Base 10)
# 0.625 = 6/10 + 2/100 + 5/1000

# FracciÃ³n Binaria (Base 2)
# 0.101 = 1/2 + 0/4 + 1/8

# En este caso raro, el valor es idÃ©ntico.
# Pero para la mayorÃ­a (como 0.1), no hay traducciÃ³n exacta.
```

#### 3. **Desarrollo:**

Imagina que intentas escribir "1/3" en una hoja de papel usando decimales. Escribes `0.3`, luego `0.33`, luego `0.333`... No importa cuÃ¡nto escribas, nunca serÃ¡ _exactamente_ 1/3, solo una aproximaciÃ³n muy buena.

A tu computadora le pasa lo mismo con nÃºmeros simples como `0.1`. En binario, `0.1` es una fracciÃ³n infinitamente repetida (`0.000110011...`). Como la memoria es finita (53 bits), la computadora tiene que cortar en algÃºn punto y guardar una aproximaciÃ³n.

ğŸ”´ **Fundamental:** Entender esto es la base para no creer que tu cÃ³digo tiene un "bug" cuando las matemÃ¡ticas no dan exactas. Es una limitaciÃ³n del hardware, no de Python.

---

## B - La IlusiÃ³n de la Pantalla [ğŸŸ¡]

#### 1. **IntroducciÃ³n:**

Python te miente (por amabilidad) mostrÃ¡ndote un nÃºmero redondeado y bonito, aunque internamente guarde un nÃºmero "feo" y largo.

#### 2. **Ejemplo:**

```python
>>> 1 / 10
0.1
# Lo que ves: 0.1
# Lo que la mÃ¡quina realmente guarda (aproximadamente):
# 0.1000000000000000055511151231257827021181583404541015625
```

#### 3. **Desarrollo:**

Si Python te mostrara el valor real de los 53 bits que tiene guardados cada vez que imprimes un nÃºmero, te volverÃ­as loco leyendo 55 decimales.
Desde Python 3.1, el sistema elige la representaciÃ³n mÃ¡s corta posible que garantice que, si la vuelves a leer, sea el mismo nÃºmero.
**Ojo:** `0.1` y `0.10000000000000001` comparten la misma aproximaciÃ³n binaria en tu mÃ¡quina.

ğŸŸ¡ **Importante:** Recuerda siempre: EstÃ¡s viendo una "ilusiÃ³n" redondeada para facilitar la lectura.

---

## C - Errores de AritmÃ©tica (El caso del 0.3) [ğŸ”´]

#### 1. **IntroducciÃ³n:**

Como los nÃºmeros son aproximaciones, sumar varios errores pequeÃ±os puede resultar en un error visible.

#### 2. **Ejemplo:**

```python
>>> 0.1 + 0.1 + 0.1 == 0.3
False

# Â¿Por quÃ©? Veamos la realidad:
# 0.1 + 0.1 + 0.1 da internamente algo como 0.30000000000000004
# Y eso NO es exactamente igual a 0.3
```

#### 3. **Desarrollo:**

Esta es la trampa mÃ¡s comÃºn para principiantes. Nunca asumas que las operaciones con punto flotante darÃ¡n el resultado decimal exacto que harÃ­as en papel. El pequeÃ±o "polvo" de error se acumula.

ğŸ”´ **Fundamental:** JamÃ¡s uses `==` para comparar floats directamente si el resultado proviene de una operaciÃ³n matemÃ¡tica.

---

## D - ComparaciÃ³n Segura: `math.isclose()` [ğŸŸ¡]

#### 1. **IntroducciÃ³n:**

La forma correcta de comparar si dos floats son "iguales" es preguntar si estÃ¡n "muy cerca" el uno del otro.

#### 2. **Ejemplo:**

```python
import math

# Forma INCORRECTA
print(0.1 + 0.1 + 0.1 == 0.3) # -> False

# Forma CORRECTA
print(math.isclose(0.1 + 0.1 + 0.1, 0.3)) # -> True
```

#### 3. **Desarrollo:**

`math.isclose()` verifica si los valores son lo suficientemente cercanos como para considerarse iguales en la prÃ¡ctica, ignorando esas minÃºsculas diferencias de error de representaciÃ³n.

ğŸŸ¡ **Importante:** Esta es la herramienta estÃ¡ndar para tests y lÃ³gica condicional con floats.

---

## E - ComparaciÃ³n con `round()` [ğŸ”µ]

#### 1. **IntroducciÃ³n:**

Una alternativa para comparar es redondear ambos nÃºmeros a una cantidad de decimales fija antes de comparar, Ãºtil para aproximaciones "gruesas".

#### 2. **Ejemplo:**

```python
import math

# Comparar PI con 22/7 (que es una aprox. de PI)
# math.pi es 3.14159...
# 22 / 7  es 3.14285...

# Comparando solo 2 decimales:
print(round(math.pi, 2) == round(22 / 7, 2)) # -> True
```

**Advertencia Paranoica:**
No intentes usar `round()` para "arreglar" el nÃºmero y luego seguir operando. `round()` no cambia el hecho de que el float subyacente sigue siendo binario e inexacto. Solo sirve para la comparaciÃ³n inmediata o para mostrarlo.

---

## F - Formateo de Salida (EstÃ©tica) [ğŸ”µ]

#### 1. **IntroducciÃ³n:**

Si solo quieres que el nÃºmero se vea bonito para el usuario (sin cambiar su valor matemÃ¡tico), usa formateo de cadenas.

#### 2. **Ejemplo:**

```python
import math

# Mostrar 2 decimales
print(format(math.pi, '.2f'))  # -> '3.14'

# Mostrar 12 dÃ­gitos significativos
print(format(math.pi, '.12g')) # -> '3.14159265359'

# Ver la representaciÃ³n "cruda" (Ãºtil para debugging)
print(repr(math.pi))           # -> '3.141592653589793'
```

ğŸ”µ **EspecÃ­fico:** Ãšsalo para reportes, interfaces de usuario o logs, pero no para cÃ¡lculos matemÃ¡ticos.

---

## G - Alternativas Exactas: `decimal` y `fractions` [ğŸŸ¡]

#### 1. **IntroducciÃ³n:**

Si necesitas precisiÃ³n absoluta (como en contabilidad) y no puedes permitirte errores de redondeo, no uses `float`.

#### 2. **Ejemplo:**

```python
from decimal import Decimal
from fractions import Fraction

# MÃ³dulo DECIMAL (Ideal para dinero/contabilidad)
# Se basa en aritmÃ©tica decimal, no binaria.
print(Decimal('0.1') * 3) # -> 0.3 (Exacto)

# MÃ³dulo FRACTIONS (Ideal para matemÃ¡ticas puras)
# Guarda numerador y denominador por separado.
f = Fraction(1, 3)
print(f + f + f) # -> 1 (Exacto, porque 1/3 + 1/3 + 1/3 = 1)
```

#### 3. **Desarrollo:**

- **`decimal`**: Implementa aritmÃ©tica decimal general. Es mÃ¡s lento que los floats pero exacto para lo que los humanos esperan.
- **`fractions`**: Mantiene los nÃºmeros como racionales (1/3).

ğŸŸ¡ **Importante:** Si estÃ¡s programando una aplicaciÃ³n bancaria, **USA DECIMAL**.

---

## H - Herramientas de InspecciÃ³n [ğŸ”µ]

#### 1. **IntroducciÃ³n:**

MÃ©todos para ver exactamente cÃ³mo la computadora estÃ¡ guardando tu nÃºmero, Ãºtiles para debugging profundo o intercambio de datos.

#### 2. **Ejemplo:**

```python
x = 3.14159

# 1. Verlo como fracciÃ³n de enteros
print(x.as_integer_ratio())
# -> (3537115888337719, 1125899906842624)
# Si divides esos dos nÃºmeros, obtienes el valor exacto de x.

# 2. Verlo en Hexadecimal (RepresentaciÃ³n exacta de memoria)
print(x.hex())
# -> '0x1.921f9f01b866ep+1'
# Esto es portable entre lenguajes (Java, C, etc.) sin perder precisiÃ³n.
```

---

## I - Suma de PrecisiÃ³n: `sum` vs `math.fsum` [ğŸŸ¡]

#### 1. **IntroducciÃ³n:**

Sumar muchos floats puede acumular errores. Python ofrece diferentes herramientas segÃºn la precisiÃ³n que necesites.

#### 2. **Comparativa:**

| MÃ©todo                 | PrecisiÃ³n  | Velocidad | Uso Recomendado                                                         |
| :--------------------- | :--------- | :-------- | :---------------------------------------------------------------------- |
| **Bucle `for` simple** | Baja       | Media     | Evitar para sumas crÃ­ticas. Acumula error en cada paso.                 |
| **`sum()`**            | Media/Alta | Alta      | Uso general. Usa precisiÃ³n extendida internamente para mitigar errores. |
| **`math.fsum()`**      | **MÃ¡xima** | Baja      | Casos cientÃ­ficos/crÃ­ticos donde los valores se cancelan entre sÃ­.      |

#### 3. **Ejemplo de la diferencia:**

```python
import math

# Lista de valores problemÃ¡ticos (grandes y pequeÃ±os que se cancelan)
arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,
       -143401161400469.7, 266262841.31058735, -0.003244936839808227]

# Bucle for (acumulador simple) -> Resultado CATASTRÃ“FICO
# Da -0.005... (Totalmente incorrecto, perdiÃ³ todos los dÃ­gitos correctos)

# sum(arr) -> Resultado DECENTE
# Da 8.042178...e-13 (Tiene error, pero se acerca)

# math.fsum(arr) -> Resultado EXACTO (dentro de lo posible)
print(math.fsum(arr))
# -> 8.042173697819788e-13
```

**ExplicaciÃ³n Paranoica:**
`math.fsum()` rastrea los "dÃ­gitos perdidos" en cada suma intermedia para reincorporarlos. Es mÃ¡s lento, pero si estÃ¡s sumando valores muy grandes con valores muy pequeÃ±os y necesitas que el resultado sea fiable, es tu salvavidas. Para el 99% de los casos cotidianos, `sum()` estÃ¡ndar es suficiente y mejor que un bucle `for`.

---

## J - Error de RepresentaciÃ³n (Detalle TÃ©cnico) [ğŸ”µ]

#### 1. **IntroducciÃ³n:**

Â¿Por quÃ© exactamente `0.1` no es exacto? Porque matemÃ¡ticamente no existe un nÃºmero entero `J` y una potencia `N` tal que `J / 2**N` sea igual a `1/10`.

#### 2. **Ejemplo:**

La computadora intenta resolver: `J / 2**56 â‰ˆ 1/10`.
El resultado mÃ¡s cercano posible en hardware moderno (IEEE 754) es:
`3602879701896397 / 2 ** 55`

Si multiplicas eso:

```python
print(3602879701896397 / 2 ** 55)
# -> 0.1 (La ilusiÃ³n)

print(3602879701896397 * 10**55 // 2**55)
# -> 10000000000000000555... (La realidad: es un poquito mÃ¡s grande que 0.1)
```

#### 3. **Desarrollo:**

Este error es inherente al hardware. La mayorÃ­a de las mÃ¡quinas tienen un error mÃ¡ximo de 1 parte en 2\*\*53 por operaciÃ³n. Es minÃºsculo, pero existe.

ğŸ”µ **EspecÃ­fico:** Solo necesitas saber esto si estÃ¡s haciendo anÃ¡lisis numÃ©rico de muy bajo nivel o necesitas explicarle a tu jefe por quÃ© el reporte financiero tiene un error de 0.00000001 centavos (Â¡usa `decimal` para eso!).
