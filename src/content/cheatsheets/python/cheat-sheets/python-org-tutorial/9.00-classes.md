---
title: "9.0 - Clases en Python: De Cero a Experto"
description: "Gu铆a definitiva sobre POO en Python, scopes, herencia e iteradores basada en la documentaci贸n oficial."
tags: ["python", "classes", "oop", "scopes", "inheritance"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Clases e Instancias: El Molde y el Objeto []

#### 1. **Introducci贸n:**

Una **Clase** es como un plano o molde, y una **Instancia** es el objeto real creado a partir de ese molde.

#### 2. **Ejemplo:**

```python
# La Clase (El plano)
class Robot:
    pass

# La Instancia (El robot real construido)
mi_robot = Robot()
```

**Explicaci贸n del ejemplo:**
`class Robot:` define un nuevo _tipo_ de cosa. `mi_robot = Robot()` crea una _instancia_ (un objeto espec铆fico) de ese tipo. Puedes crear infinitos robots usando la misma clase `Robot`.

#### 3. **Desarrollo:**

Las clases permiten agrupar datos (atributos) y funcionalidad (m茅todos). Python es muy din谩mico: las clases se crean en tiempo de ejecuci贸n y pueden modificarse despu茅s de creadas. A diferencia de C++, en Python todo es p煤blico por defecto y todos los m茅todos son virtuales (se pueden sobreescribir).

 **Fundamental**: Sin entender que la clase es la f谩brica y la instancia es el producto, no podr谩s avanzar en Programaci贸n Orientada a Objetos (POO).

---

## B - Aliasing: El Fen贸meno de las Etiquetas Adhesivas []

#### 1. **Introducci贸n:**

El Aliasing ocurre cuando tienes dos nombres diferentes (variables) pegados al **mismo** objeto en la memoria.

#### 2. **Ejemplo:**

```python
lista_a = [1, 2, 3]
lista_b = lista_a  # 隆Cuidado! No es una copia, es un alias.

lista_b.append(4)
print(lista_a)
# Salida: [1, 2, 3, 4] -> 隆lista_a cambi贸 aunque tocamos lista_b!
```

**Explicaci贸n del ejemplo:**
Python no copia los objetos al asignarlos, solo pasa "punteros" (referencias). `lista_a` y `lista_b` son dos etiquetas pegadas a la misma lista.

#### 3. **Desarrollo:**

Esto suele ignorarse con tipos inmutables (n煤meros, strings) porque no puedes cambiarlos. Pero con objetos mutables (listas, diccionarios, clases), el aliasing puede causar bugs si no est谩s atento. Sin embargo, es 煤til porque hace que pasar objetos a funciones sea muy "barato" en t茅rminos de memoria (no se duplica la informaci贸n).

 **Importante**: Entender esto te salvar谩 de horas de depuraci贸n pregunt谩ndote "驴por qu茅 cambi贸 mi variable X si yo solo toqu茅 Y?".

---

## C - Namespaces (Espacios de Nombres) []

#### 1. **Introducci贸n:**

Un Namespace es simplemente un diccionario que mapea nombres a objetos; asegura que el nombre `x` en tu c贸digo no choque con el nombre `x` de una librer铆a importada.

#### 2. **Ejemplo:**

```python
# Namespace del m贸dulo A
def funcion():
    return "Soy A"

# Namespace del m贸dulo B
def funcion():
    return "Soy B"

# No hay conflicto, se accede con el prefijo (el "apellido")
import modulo_a
import modulo_b
modulo_a.funcion()
modulo_b.funcion()
```

#### 3. **Desarrollo:**

Los namespaces se crean en diferentes momentos (al iniciar Python, al importar un m贸dulo, al llamar una funci贸n) y tienen diferentes tiempos de vida. Lo vital es saber que **no hay relaci贸n** entre nombres de distintos namespaces.

 **Fundamental**: Es la base de c贸mo Python organiza las variables para que no se mezclen.

---

## D - Scopes (mbitos) y Regla de B煤squeda []

#### 1. **Introducci贸n:**

El Scope es la regi贸n del c贸digo donde un namespace es accesible directamente; Python busca las variables en capas, desde adentro hacia afuera.

#### 2. **Ejemplo:**

```python
x = "Global"

def exterior():
    x = "Enclosing (Cercano)"

    def interior():
        x = "Local"
        print(x) # Busca aqu铆 primero -> Encuentra "Local"

    interior()

exterior()
```

#### 3. **Desarrollo:**

Aunque los scopes se definen textualmente (d贸nde escribes el c贸digo), la b煤squeda es din谩mica. El orden de b煤squeda es:

1.  **Local**: Dentro de la funci贸n actual.
2.  **Enclosing**: En funciones que envuelven a la actual.
3.  **Global**: En el m贸dulo actual.
4.  **Built-in**: Nombres predefinidos de Python (como `len`, `print`).

 **Fundamental**: Si no entiendes d贸nde busca Python tus variables, no sabr谩s qu茅 valor est谩 usando tu programa.

---

## E - Keywords `global` y `nonlocal` []

#### 1. **Introducci贸n:**

Sirven para modificar variables que viven fuera de tu scope local actual, en lugar de crear una nueva variable local.

#### 2. **Ejemplo:**

```python
spam = "original"

def prueba_scopes():
    def do_local():
        spam = "local" # Crea variable nueva local, no toca la de afuera

    def do_nonlocal():
        nonlocal spam  # Dice: "Usa la variable de la funci贸n 'prueba_scopes'"
        spam = "nonlocal"

    def do_global():
        global spam    # Dice: "Usa la variable del m贸dulo (arriba de todo)"
        spam = "global"

    spam = "test spam"
    do_local()
    print("Tras local:", spam)    # Imprime: test spam (no cambi贸)
    do_nonlocal()
    print("Tras nonlocal:", spam) # Imprime: nonlocal (cambi贸 la de prueba_scopes)
    do_global()
    print("Tras global:", spam)   # Imprime: nonlocal (隆OJO! global cambi贸 la de afuera del todo, no esta)

prueba_scopes()
print("En scope global:", spam)   # Imprime: global
```

#### 3. **Desarrollo:**

- **Sin keyword**: Asignar `x = 1` crea una variable local nueva.
- **`nonlocal x`**: Busca `x` en el scope de la funci贸n que te envuelve (煤til en funciones anidadas).
- **`global x`**: Busca `x` en el nivel superior del m贸dulo.

 **Espec铆fico**: No se usan todo el tiempo, pero son imprescindibles cuando necesitas modificar estado externo desde una funci贸n interna.

---

## F - Sintaxis de Definici贸n y Objetos de Clase []

#### 1. **Introducci贸n:**

Al definir una clase, se crea un nuevo namespace. Al terminar la definici贸n, se crea un "Objeto de Clase" que permite acceder a atributos y crear instancias.

#### 2. **Ejemplo:**

```python
class MiClase:
    """Documentaci贸n simple"""
    i = 12345       # Atributo de clase

    def f(self):    # Definici贸n de funci贸n (m茅todo)
        return 'hola mundo'

# Usando el Objeto de Clase
print(MiClase.i)    # Acceso a atributo -> 12345
x = MiClase()       # Instanciaci贸n -> Crea un nuevo objeto 'x'
```

#### 3. **Desarrollo:**

La definici贸n de clase debe ejecutarse para tener efecto. El "Objeto de Clase" (`MiClase`) es b谩sicamente un envoltorio alrededor del namespace creado. Soporta dos operaciones: referencias a atributos (`MiClase.i`) e instanciaci贸n (`MiClase()`).

 **Fundamental**: Es la sintaxis b谩sica para crear tus propios tipos de datos.

---

## G - El m茅todo `__init__` (El Constructor) []

#### 1. **Introducci贸n:**

Es un m茅todo especial que Python ejecuta autom谩ticamente al crear una nueva instancia para darle un estado inicial.

#### 2. **Ejemplo:**

```python
class Complejo:
    def __init__(self, parte_real, parte_imag):
        self.r = parte_real
        self.i = parte_imag

x = Complejo(3.0, -4.5) # Python llama a __init__ con estos valores
print(x.r, x.i)         # Salida: 3.0 -4.5
```

#### 3. **Desarrollo:**

Piensa en `__init__` como la configuraci贸n de f谩brica. Si no lo defines, obtienes un objeto vac铆o. Si lo defines con argumentos, debes pasarlos al crear la instancia (como `3.0` y `-4.5` arriba).

 **Fundamental**: Casi todas las clases que escribas necesitar谩n un `__init__` para ser 煤tiles.

---

## H - Objetos M茅todo y el argumento `self` []

#### 1. **Introducci贸n:**

Un m茅todo es una funci贸n que "pertenece" a un objeto. El primer argumento (`self`) es el propio objeto, que Python pasa autom谩ticamente.

#### 2. **Ejemplo:**

```python
class MiClase:
    def saludar(self):
        return "Hola"

x = MiClase()

# Estas dos l铆neas hacen EXACTAMENTE lo mismo:
x.saludar()          # Forma corta (Python pone 'x' en 'self' por ti)
MiClase.saludar(x)   # Lo que realmente pasa tras bambalinas
```

**Explicaci贸n del ejemplo:**
Cuando llamas a `x.saludar()`, Python lo traduce a "Busca la funci贸n `saludar` en la clase de `x` y ll谩mala pasando a `x` como primer argumento". Por eso definimos `def saludar(self):` con un argumento, pero lo llamamos `x.saludar()` sin ninguno.

#### 3. **Desarrollo:**

`self` es solo una convenci贸n (podr铆as llamarlo `pepito`), pero **por favor usa `self`** o nadie entender谩 tu c贸digo. Los m茅todos pueden guardarse en variables y llamarse despu茅s (`xf = x.f; xf()`).

 **Fundamental**: La confusi贸n sobre por qu茅 sobra o falta un argumento suele venir de no entender que `self` se pasa solo.

---

## I - Variables de Clase vs. Variables de Instancia []

#### 1. **Introducci贸n:**

Las variables de **instancia** son 煤nicas para cada objeto (ej. el nombre de un perro). Las de **clase** se comparten entre todos los objetos (ej. la especie "Canino").

#### 2. **Ejemplo (隆Cuidado con la trampa!):**

**Forma Correcta:**

```python
class Perro:
    especie = 'canino'         # Variable de Clase (compartida)

    def __init__(self, nombre):
        self.nombre = nombre   # Variable de Instancia (煤nica)

d = Perro('Fido')
e = Perro('Buddy')
# d.especie y e.especie son 'canino'.
# d.nombre es 'Fido', e.nombre es 'Buddy'.
```

**La Trampa de los Mutables (Listas/Diccionarios):**

```python
class PerroMalo:
    trucos = [] # 隆ERROR! Esta lista es compartida por TODOS los perros

    def agregar_truco(self, truco):
        self.trucos.append(truco)

d = PerroMalo()
e = PerroMalo()
d.agregar_truco('rodar')
print(e.trucos) # Salida: ['rodar'] -> 隆El perro 'e' aprendi贸 el truco de 'd'!
```

**La Soluci贸n:**
Para evitar compartir la lista, inicial铆zala dentro de `__init__` usando `self.trucos = []`.

#### 3. **Desarrollo:**

Usa variables de clase solo para datos que deben ser id茅nticos para todas las instancias. Para todo lo dem谩s (especialmente listas o diccionarios que van a cambiar), usa variables de instancia dentro de `__init__`.

 **Importante**: Es el error n煤mero 1 de los principiantes en clases de Python.

---

## J - Herencia Simple y Prioridad de Atributos []

#### 1. **Introducci贸n:**

Una clase derivada hereda atributos y m茅todos de una clase base. Si un atributo existe en la instancia y en la clase, gana la instancia.

#### 2. **Ejemplo:**

```python
class Base:
    def hola(self):
        print("Hola desde Base")

class Derivada(Base): # Hereda de Base
    def hola(self):   # Sobreescribe (Override) el m茅todo
        print("Hola desde Derivada")

d = Derivada()
d.hola() # Imprime: "Hola desde Derivada"
```

#### 3. **Desarrollo:**

Python busca el atributo/m茅todo as铆:

1.  En la instancia.
2.  En la clase de la instancia.
3.  En la clase base (y sus padres recursivamente).

Si quieres llamar al m茅todo original del padre dentro del hijo, puedes usar `Base.hola(self)`.

 **Importante**: Permite reutilizar c贸digo y especializar comportamientos.

---

## K - Herencia M煤ltiple []

#### 1. **Introducci贸n:**

Una clase puede heredar de m谩s de un padre. Python tiene un algoritmo complejo (MRO) para decidir a qui茅n llamar, pero b谩sicamente busca de izquierda a derecha y en profundidad.

#### 2. **Ejemplo:**

```python
class Derivada(Base1, Base2, Base3):
    pass
```

#### 3. **Desarrollo:**

La b煤squeda de atributos ocurre primero en `Derivada`, luego en `Base1` (y sus padres), luego en `Base2`, etc. Python usa un orden din谩mico para asegurar que cada padre se llame una sola vez (importante para `super()`) y resolver el "problema del diamante".

 **Espec铆fico**: til, pero puede complicar el c贸digo. salo con moderaci贸n.

---

## L - Variables Privadas y Name Mangling []

#### 1. **Introducci贸n:**

En Python **no existe** lo "privado" real. Todo es accesible. Pero hay convenciones y trucos.

#### 2. **Ejemplo:**

```python
class Mapeo:
    def __init__(self):
        self._interno = 1   # Convenci贸n: "Por favor, no toques esto desde fuera"
        self.__secreto = 2  # Mangling: Python le cambia el nombre para protegerlo

x = Mapeo()
print(x._interno)           # Funciona, pero es de mala educaci贸n.
# print(x.__secreto)        # Error! No existe con ese nombre.
print(x._Mapeo__secreto)    # Funciona! El nombre real es _Clase__variable.
```

#### 3. **Desarrollo:**

- `_nombre`: Convenci贸n. Significa "uso interno".
- `__nombre`: Name Mangling. Python renombra la variable a `_NombreClase__nombre` para evitar colisiones accidentales en subclases.

 **Espec铆fico**: til principalmente para autores de librer铆as que quieren evitar conflictos de nombres en herencias complejas.

---

## M - Dataclasses (Structs) []

#### 1. **Introducci贸n:**

Si solo quieres una clase para guardar datos (como un `struct` en C o un registro en Pascal), usa `@dataclass`. Te ahorra escribir el `__init__` y otros m茅todos.

#### 2. **Ejemplo:**

```python
from dataclasses import dataclass

@dataclass
class Empleado:
    nombre: str
    depto: str
    salario: int

juan = Empleado('Juan', 'IT', 1000)
print(juan.nombre)
```

 **Espec铆fico**: La forma moderna y limpia de agrupar datos.

---

## N - Iteradores: C贸mo funciona el bucle `for` []

#### 1. **Introducci贸n:**

Cuando haces `for x in objeto:`, Python usa un protocolo invisible llamado Iterador. Tu objeto debe tener `__iter__` y `__next__`.

#### 2. **Ejemplo:**

```python
s = 'abc'
it = iter(s)    # Obtiene el iterador
print(next(it)) # 'a'
print(next(it)) # 'b'
# Cuando se acaban, next() lanza la excepci贸n StopIteration
```

#### 3. **Desarrollo:**

Para que tu clase sea iterable:

1.  Define `__iter__(self)`: Debe devolver un objeto con m茅todo `__next__` (usualmente `self`).
2.  Define `__next__(self)`: Debe devolver el siguiente valor o lanzar `StopIteration` cuando termine.

 **Importante**: Entender esto desmitifica la "magia" de los bucles en Python.

---

## O - Generadores: Iteradores F谩ciles []

#### 1. **Introducci贸n:**

Los generadores son una forma simple de crear iteradores. Son funciones que usan `yield` en lugar de `return`.

#### 2. **Ejemplo:**

```python
def cuenta_regresiva(n):
    while n > 0:
        yield n  # "Pausa" la funci贸n y entrega el valor
        n -= 1

for x in cuenta_regresiva(3):
    print(x)
# Salida: 3, 2, 1
```

#### 3. **Desarrollo:**

Cada vez que llamas a `next()` en un generador, este contin煤a desde donde se qued贸 (despu茅s del 煤ltimo `yield`), recordando todas sus variables locales. Python crea autom谩ticamente los m茅todos `__iter__` y `__next__` por ti.

 **Importante**: Son muy eficientes en memoria porque generan los valores uno a uno, no todos de golpe en una lista.

---

## P - Expresiones Generadoras []

#### 1. **Introducci贸n:**

Son como las "List Comprehensions" (comprensi贸n de listas) pero usan par茅ntesis `()` en lugar de corchetes `[]`. Crean un generador al vuelo.

#### 2. **Ejemplo:**

```python
# Suma de cuadrados sin crear una lista gigante en memoria
suma = sum(i*i for i in range(10))

# Lista vs Generador
lista = [x for x in range(10)] # Ocupa memoria para 10 elementos
gen = (x for x in range(10))   # Ocupa memoria m铆nima, genera bajo demanda
```

 **Espec铆fico**: Ideales para operaciones r谩pidas y eficientes en memoria dentro de funciones como `sum()`, `max()`, etc.
