---
title: "6 - M√≥dulos y Paquetes en Python"
description: "Gu√≠a definitiva para organizar, reutilizar y estructurar c√≥digo en Python"
tags: ["python", "modules", "packages", "import"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Script vs. M√≥dulo: ¬øPrograma o Herramienta? üî¥

#### 1. **Introducci√≥n:**

Un **Script** es un archivo dise√±ado para ejecutarse directamente (como un programa principal), mientras que un **M√≥dulo** es un archivo lleno de herramientas (funciones, variables) dise√±ado para ser importado y usado por otros scripts.

#### 2. **Ejemplo:**

```python
# Archivo: herramientas.py
# Si lo ejecutas directamente: python herramientas.py -> Es un SCRIPT
# Si lo usas en otro lado: import herramientas -> Es un M√ìDULO

def saludar(nombre):
    print(f"Hola, {nombre}")
```

#### 3. **Desarrollo:**

Cuando sales del int√©rprete de Python, pierdes todas tus variables. Para guardar tu trabajo, escribes el c√≥digo en un archivo de texto. Si ese archivo crece, lo divides. Un m√≥dulo es simplemente un archivo con extensi√≥n `.py`. El nombre del archivo (sin el `.py`) se convierte en el nombre del m√≥dulo dentro de Python.

üî¥ **Fundamental**: Entender esto es la base de la programaci√≥n modular. No escribas todo tu c√≥digo en un solo archivo gigante; div√≠delo en m√≥dulos l√≥gicos.

## B - Importaci√≥n B√°sica (`import`) üî¥

#### 1. **Introducci√≥n:**

Usa `import nombre_archivo` para acceder a todo el contenido de ese m√≥dulo, pero manteni√©ndolo ordenado dentro de su propio "espacio".

#### 2. **Ejemplo:**

```python
# Tienes un archivo llamado fibo.py con una funci√≥n fib(n)

import fibo  # Trae el m√≥dulo, pero NO sus funciones directamente

fibo.fib(100) # CORRECTO: Debes usar el "apellido" del m√≥dulo
# fib(100)    # ERROR: Python no sabe qu√© es 'fib' todav√≠a
```

#### 3. **Desarrollo:**

Al hacer `import fibo`, Python **no** mezcla las funciones de `fibo` con las tuyas. Crea un objeto llamado `fibo` y mete todo adentro. Esto es genial porque evita conflictos de nombres (ej: si t√∫ tienes una funci√≥n `fib` y el m√≥dulo tambi√©n, no se pelean).

üî¥ **Fundamental**: Es la forma m√°s segura y ordenada de traer c√≥digo externo.

## C - Importaci√≥n Espec√≠fica (`from ... import`) üü°

#### 1. **Introducci√≥n:**

Usa esta variante si quieres traer una funci√≥n espec√≠fica directamente a tu c√≥digo, ahorr√°ndote escribir el nombre del m√≥dulo cada vez.

#### 2. **Ejemplo:**

```python
from fibo import fib, fib2

fib(500)  # AHORA S√ç: Puedes usarla directamente sin 'fibo.'
# fibo.fib(500) # ERROR: El nombre 'fibo' no fue importado, solo la funci√≥n
```

#### 3. **Desarrollo:**

**Comparaci√≥n Paranoica: `import` vs `from ... import`**

- Usa `import modulo`: Cuando quieras claridad total sobre de d√≥nde viene una funci√≥n (`modulo.funcion()`).
- Usa `from modulo import funcion`: Cuando vas a usar esa funci√≥n much√≠simas veces y te da pereza escribir el prefijo. **¬°Cuidado!** Si ya ten√≠as una variable con ese nombre, la sobrescribir√°s sin aviso.

üü° **Importante**: Muy usado, pero requiere cuidado para no "pisar" nombres de variables existentes.

## D - Importaci√≥n con Alias (`as`) üü°

#### 1. **Introducci√≥n:**

Si el nombre del m√≥dulo es muy largo o choca con una variable tuya, puedes ponerle un apodo (alias) en el momento de importar.

#### 2. **Ejemplo:**

```python
import fibo as f          # Renombrando el m√≥dulo
f.fib(500)                # Usamos el alias 'f'

from fibo import fib as fibonacci_super_rapido  # Renombrando la funci√≥n
fibonacci_super_rapido(500)
```

üü° **Importante**: Esencial para librer√≠as con nombres comunes o largos (ej: `import pandas as pd`, `import numpy as np`).

## E - La Trampa del `from ... import *` ‚ö™

#### 1. **Introducci√≥n:**

Importa **todos** los nombres de un m√≥dulo a tu c√≥digo actual, excepto los que empiezan con `_`.

#### 2. **Ejemplo:**

```python
from fibo import *
# Ahora tienes fib, fib2, y cualquier otra cosa que estuviera en fibo.py
# mezclado con tus variables. ¬°Caos potencial!
```

#### 3. **Desarrollo:**

Parece c√≥modo para ahorrar tiempo, pero **ev√≠talo en c√≥digo profesional**. Hace que el c√≥digo sea dif√≠cil de leer (¬øde d√≥nde sali√≥ esta funci√≥n?) y puede sobrescribir tus variables silenciosamente. Solo es aceptable para sesiones interactivas r√°pidas en la consola.

‚ö™ **Raramente usado**: Desaconsejado en scripts finales por mala legibilidad y riesgo de conflictos.

## F - Ejecuci√≥n de C√≥digo al Importar üîµ

#### 1. **Introducci√≥n:**

Un m√≥dulo puede contener c√≥digo suelto (fuera de funciones). Este c√≥digo se ejecuta **inmediatamente** cuando importas el m√≥dulo, pero **solo la primera vez**.

#### 2. **Ejemplo:**

```python
# archivo: mi_modulo.py
print("¬°Me estoy inicializando!")
def func(): pass

# En tu consola:
# >>> import mi_modulo
# ¬°Me estoy inicializando!
# >>> import mi_modulo
# (No pasa nada, Python recuerda que ya lo carg√≥)
```

#### 3. **Desarrollo:**

Esto se usa para inicializar variables o configuraciones del m√≥dulo. Si modificas el archivo y necesitas recargarlo sin cerrar Python, debes usar `importlib.reload()`, ya que un simple `import` no volver√° a leer el archivo por eficiencia.

üîµ **Espec√≠fico**: √ötil para entender el ciclo de vida de un m√≥dulo, pero no abuses de poner c√≥digo suelto.

## G - El Truco del `if __name__ == "__main__":` üî¥

#### 1. **Introducci√≥n:**

Este bloque m√°gico permite que un archivo funcione de dos formas: como un **script ejecutable** (hace algo) y como un **m√≥dulo importable** (no hace nada, solo entrega herramientas).

#### 2. **Ejemplo:**

```python
# archivo: fibo.py

def fib(n):
    # ... l√≥gica de fibonacci ...
    print(f"Calculando fib de {n}")

# Este bloque SOLO corre si ejecutas: python fibo.py
# Si haces 'import fibo', este bloque se ignora.
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
```

#### 3. **Desarrollo:**

Cada m√≥dulo tiene una variable oculta llamada `__name__`.

- Si lo importas, `__name__` vale el nombre del archivo (`"fibo"`).
- Si lo ejecutas directamente, `__name__` vale `"__main__"`.
  Este `if` comprueba esa variable. Es vital para crear m√≥dulos que tambi√©n sirvan como herramientas de l√≠nea de comandos o para incluir tests simples dentro del mismo archivo.

üî¥ **Fundamental**: Ver√°s esto en casi todos los scripts profesionales de Python.

## H - El Search Path (`sys.path`): ¬øD√≥nde busca Python? üîµ

#### 1. **Introducci√≥n:**

Cuando haces `import spam`, Python busca el archivo `spam.py` en una lista espec√≠fica de carpetas, en un orden estricto.

#### 2. **Ejemplo:**

```python
import sys
print(sys.path)
# Salida t√≠pica:
# 1. Directorio actual (donde est√° tu script)
# 2. PYTHONPATH (variables de entorno)
# 3. Directorios de instalaci√≥n por defecto (librer√≠as est√°ndar)
```

#### 3. **Desarrollo:**

**¬°Cuidado Paranoico!** El directorio actual tiene prioridad. Si creas un archivo llamado `math.py` en tu carpeta, y haces `import math`, Python cargar√° **tu** archivo en lugar de la librer√≠a matem√°tica est√°ndar. Esto romper√° todo tu c√≥digo. **Nunca llames a tus archivos igual que las librer√≠as est√°ndar.**

üîµ **Espec√≠fico**: Importante para depurar errores de "Module not found" o importaciones incorrectas.

## I - Archivos Compilados (`__pycache__`) üîµ

#### 1. **Introducci√≥n:**

Para cargar m√°s r√°pido, Python guarda una versi√≥n "compilada" de tus m√≥dulos en la carpeta `__pycache__` con extensi√≥n `.pyc`.

#### 2. **Ejemplo:**

Ver√°s una carpeta `__pycache__/spam.cpython-38.pyc`.

#### 3. **Desarrollo:**

No te asustes si ves aparecer esta carpeta. Es autom√°tica. Python revisa la fecha: si cambiaste el `.py`, recompila el `.pyc`. Si no, usa el `.pyc` para arrancar m√°s r√°pido.
_Nota:_ Los `.pyc` son independientes de la plataforma (funcionan en Linux/Windows) y no hacen que el programa corra m√°s r√°pido, solo que se **cargue** (import) m√°s r√°pido.

üîµ **Espec√≠fico**: Informaci√≥n de fondo. Puedes ignorar estos archivos (y a√±adirlos a tu `.gitignore`).

## J - La funci√≥n `dir()` üü°

#### 1. **Introducci√≥n:**

Una herramienta de "rayos X" para ver qu√© nombres (funciones, variables) define un m√≥dulo.

#### 2. **Ejemplo:**

```python
import fibo
import sys

dir(fibo) # Devuelve: ['__name__', 'fib', 'fib2']
dir()     # Sin argumentos: lista las variables que T√ö has creado hasta ahora
```

#### 3. **Desarrollo:**

`dir()` no lista las funciones integradas de Python (como `print` o `len`). Si quieres ver esas, necesitas importar `builtins` y hacer `dir(builtins)`.

üü° **Importante**: Extremadamente √∫til cuando est√°s aprendiendo una librer√≠a nueva y quieres ver qu√© funciones tiene disponibles r√°pidamente.

## K - Paquetes (Packages) üî¥

#### 1. **Introducci√≥n:**

Los paquetes son una forma de organizar muchos m√≥dulos relacionados dentro de carpetas, usando nombres con puntos (ej: `sound.effects.echo`).

#### 2. **Ejemplo:**

Estructura de carpetas necesaria:

```text
sound/                  (Carpeta Principal - Paquete "sound")
      __init__.py       (¬°Archivo M√°gico! Marca la carpeta como paquete)
      effects/          (Sub-carpeta - Sub-paquete "effects")
              __init__.py
              echo.py   (M√≥dulo "echo")
```

Uso:

```python
import sound.effects.echo
sound.effects.echo.filtro(...)
```

#### 3. **Desarrollo:**

El archivo `__init__.py` es obligatorio (en versiones antiguas y por compatibilidad) para que Python trate al directorio como un paquete. Puede estar vac√≠o, pero su presencia es la se√±al. Evita que carpetas con nombres comunes (como "string") oculten m√≥dulos del sistema.

üî¥ **Fundamental**: Indispensable para organizar proyectos grandes.

## L - Importando desde Paquetes: Variantes üü°

#### 1. **Introducci√≥n:**

Hay varias formas de traer subm√≥dulos, y la sintaxis es estricta sobre qu√© puedes importar.

#### 2. **Ejemplo:**

```python
# Opci√≥n A: Importar el m√≥dulo completo (requiere nombre largo al usar)
import sound.effects.echo
sound.effects.echo.func()

# Opci√≥n B: Importar el subm√≥dulo sin prefijo de paquete
from sound.effects import echo
echo.func()

# Opci√≥n C: Importar la funci√≥n directamente
from sound.effects.echo import func
func()
```

#### 3. **Desarrollo:**

**Regla de Oro:** En `from package import item`, el `item` puede ser un subpaquete, un m√≥dulo, o una funci√≥n/variable.
PERO, en `import item.subitem`, **cada parte debe ser un paquete o m√≥dulo** hasta el final. No puedes hacer `import sound.effects.echo.func` (eso dar√≠a error).

üü° **Importante**: Entender la diferencia evita muchos `ImportError`.

## M - `from package import *` y `__all__` üîµ

#### 1. **Introducci√≥n:**

Si haces `from sound.effects import *`, Python **no** importa todos los archivos de la carpeta autom√°ticamente (ser√≠a muy lento). El autor del paquete debe definir una lista expl√≠cita llamada `__all__` en el `__init__.py`.

#### 2. **Ejemplo:**

```python
# En sound/effects/__init__.py
__all__ = ["echo", "surround", "reverse"]

# En tu script:
from sound.effects import *
# Esto importar√° SOLO los m√≥dulos 'echo', 'surround' y 'reverse'.
```

#### 3. **Desarrollo:**

Si `__all__` no existe, `import *` solo importa el paquete en s√≠ (ejecuta `__init__.py`) y cualquier nombre definido _dentro_ de ese `__init__.py`, pero no busca archivos `.py` en la carpeta.
**Advertencia:** Si defines una funci√≥n local con el mismo nombre que un m√≥dulo en `__all__`, la funci√≥n local gana y "oculta" al m√≥dulo.

üîµ **Espec√≠fico**: Solo necesitas preocuparte por esto si est√°s creando librer√≠as para otros, o si te preguntas por qu√© `import *` no trae tus archivos nuevos.

## N - Referencias Intra-paquete (Imports Relativos) üîµ

#### 1. **Introducci√≥n:**

Cuando un m√≥dulo dentro de un paquete necesita importar a otro m√≥dulo "hermano" o "padre", puede usar puntos (`.`) en lugar del nombre completo.

#### 2. **Ejemplo:**

Est√°s editando `sound/effects/surround.py`:

```python
from . import echo          # Importa echo.py (mismo directorio)
from .. import formats      # Sube un nivel (a sound/) e importa formats
from ..filters import equalizer # Sube, entra a filters, importa equalizer
```

#### 3. **Desarrollo:**

Esto hace que tu paquete sea m√°s f√°cil de mover o renombrar, ya que los archivos no dependen del nombre "sound" expl√≠citamente.
**Nota Paranoica:** Los imports relativos **fallan** si ejecutas el archivo directamente como script (`python surround.py`). Solo funcionan si el archivo se importa como parte del paquete.

üîµ **Espec√≠fico**: √ötil para desarrolladores de librer√≠as complejas.

## O - M√≥dulos Est√°ndar Espec√≠ficos (`sys`) üîµ

#### 1. **Introducci√≥n:**

El texto destaca el m√≥dulo `sys` por su importancia en la configuraci√≥n del int√©rprete.

#### 2. **Ejemplo:**

```python
import sys
sys.ps1 = 'C> ' # Cambia el prompt principal (>>>)
sys.path.append('/mi/ruta/libs') # A√±ade carpetas donde buscar m√≥dulos
```

#### 3. **Desarrollo:**

`sys.ps1` y `sys.ps2` solo existen en modo interactivo. `sys.path` es una lista normal de Python, as√≠ que puedes usar `.append()` para ense√±ar a Python a buscar m√≥dulos en carpetas nuevas durante la ejecuci√≥n.

üîµ **Espec√≠fico**: Manipular `sys.path` es un truco avanzado para solucionar problemas de rutas.

## P - Atributo `__path__` en Paquetes ‚ö™

#### 1. **Introducci√≥n:**

Es una lista de directorios donde se busca el c√≥digo del paquete. Se inicializa autom√°ticamente con el directorio del `__init__.py`.

#### 2. **Ejemplo:**

Puedes modificar `paquete.__path__` para que el paquete incluya m√≥dulos que est√°n f√≠sicamente en otra carpeta del disco.

‚ö™ **Raramente usado**: Es una caracter√≠stica avanzada para extender paquetes complejos, raramente necesaria en el d√≠a a d√≠a.
