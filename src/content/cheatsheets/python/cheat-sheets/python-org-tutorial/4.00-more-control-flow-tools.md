---
title: "4 - Herramientas de Control de Flujo en Python"
description: "Gu铆a detallada sobre bucles, condicionales, match y definici贸n de funciones en Python"
tags: ["python", "control-flow", "functions", "loops"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Sentencias `if`, `elif` y `else` []

#### 1. **Introducci贸n:**

Es la forma en que tu programa toma decisiones: "Si pasa esto, haz aquello; si no, haz lo otro".

#### 2. **Ejemplo:**

```python
x = int(input("Ingresa un n煤mero: "))

if x < 0:
    x = 0
    print('Negativo cambiado a cero')
elif x == 0:
    print('Cero')
elif x == 1:
    print('Uno')
else:
    print('M谩s')
```

#### 3. **Desarrollo:**

- **`if`**: Eval煤a una condici贸n. Si es verdadera, entra.
- **`elif`**: Significa "Else If" (Si no, s铆...). Puedes tener tantos como quieras. Es 煤til para evitar la "escalera" de indentaci贸n que se formar铆a si usaras muchos `if` anidados.
- **`else`**: Es opcional. Se ejecuta si **ninguna** de las condiciones anteriores fue verdadera.
- Sustituye al `switch` o `case` de otros lenguajes antiguos (aunque ahora tenemos `match`, ver concepto H).

 **Fundamental**: Sin esto, tu programa ser铆a una l铆nea recta aburrida que siempre hace lo mismo.

## B - Sentencias `for` (Iteraci贸n) []

#### 1. **Introducci贸n:**

El `for` en Python no cuenta n煤meros (como en C o Pascal), sino que recorre **elementos** de una secuencia (como una lista o texto) en orden.

#### 2. **Ejemplo:**

```python
palabras = ['gato', 'ventana', 'defenestrar']

# "w" tomar谩 el valor de 'gato', luego 'ventana', etc.
for w in palabras:
    print(w, len(w))
```

#### 3. **Desarrollo:**

Olv铆date de definir el paso de iteraci贸n o la condici贸n de parada manualmente. Python te lo pone f谩cil: "Para cada cosa en esta colecci贸n, haz esto". Si la colecci贸n tiene 3 cosas, el bucle corre 3 veces.

 **Fundamental**: Es la herramienta principal para procesar datos en lote.

## C - Modificando colecciones durante la iteraci贸n []

#### 1. **Introducci贸n:**

隆Cuidado! Intentar borrar o agregar items a una lista _mientras_ la est谩s recorriendo con un `for` es peligroso y confuso.

#### 2. **Ejemplo:**

```python
users = {'Hans': 'active', 'l茅onore': 'inactive', 'J澶': 'active'}

# MALO: Iterar sobre 'users' y borrar de 'users' al mismo tiempo.
# BUENO: Iterar sobre una COPIA (.copy())
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user] # Borramos del original, pero recorremos la copia

# OTRA ESTRATEGIA: Crear una colecci贸n nueva
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status
```

#### 3. **Desarrollo:**

Si modificas la lista sobre la que est谩s "caminando", Python puede saltarse elementos o procesarlos dos veces.

- **Regla de oro**: Si vas a modificar, itera sobre una **copia** o construye una **lista nueva**.

 **Importante**: Es un error muy com煤n de principiante que causa bugs dif铆ciles de rastrear.

## D - La funci贸n `range()` []

#### 1. **Introducci贸n:**

Si realmente necesitas iterar sobre una secuencia de n煤meros, `range()` los genera por ti "al vuelo".

#### 2. **Ejemplo:**

```python
# Genera: 0, 1, 2, 3, 4 (El 5 NO se incluye)
for i in range(5):
    print(i)

# range(inicio, fin, paso)
list(range(0, 10, 3))   # [0, 3, 6, 9]
list(range(-10, -100, -30)) # [-10, -40, -70]

# Combinado con len() para obtener 铆ndices
a = ['Mary', 'ten铆a', 'un', 'corderito']
for i in range(len(a)):
    print(i, a[i])
```

#### 3. **Desarrollo:**

- El punto final **nunca** es parte de la secuencia generada (`range(5)` genera 5 valores, del 0 al 4).
- **Nota t茅cnica**: `range()` devuelve un objeto "iterable". No crea la lista de n煤meros en memoria de golpe (para ahorrar espacio), los calcula uno a uno cuando el `for` se lo pide. Por eso si haces `print(range(10))` solo ves "range(0, 10)".

 **Fundamental**: Esencial para bucles num茅ricos cl谩sicos.

## E - `break` vs `continue` []

#### 1. **Introducci贸n:**

Son las herramientas para alterar el comportamiento normal de un bucle desde dentro.

#### 2. **Ejemplo:**

```python
# BREAK: Rompe el bucle totalmente
for n in range(2, 10):
    if n == 5:
        break # Se sale del for inmediatamente
    print(n) # Imprime 2, 3, 4 y termina.

# CONTINUE: Salta solo esta vuelta
for n in range(2, 10):
    if n % 2 == 0:
        print(f"Par encontrado: {n}")
        continue # Salta al siguiente n煤mero del for, ignora lo de abajo
    print(f"Impar encontrado: {n}")
```

#### 3. **Desarrollo:**

Aqu铆 es donde muchos se confunden, as铆 que vamos a dejarlo claro:

- **`break`**: Es el bot贸n de **EJECT**. "S谩came de aqu铆 ahora mismo". Termina el bucle m谩s interno donde se encuentre.
- **`continue`**: Es el bot贸n de **SKIP**. "Ya termin茅 con este 铆tem, pasa al siguiente". Deja de ejecutar el c贸digo actual y vuelve al inicio del bucle con el siguiente valor.

 **Importante**: Te dan control fino sobre la l贸gica del bucle sin tener que anidar `if` gigantescos.

## F - Cl谩usula `else` en Bucles []

#### 1. **Introducci贸n:**

S铆, los bucles `for` y `while` pueden tener un `else`. Este `else` se ejecuta **solo si el bucle termin贸 naturalmente** (sin usar `break`).

#### 2. **Ejemplo:**

```python
# Buscando n煤meros primos
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(f"{n} es igual a {x} * {n//x}")
            break # Encontramos un factor, NO es primo, rompemos.
    else:
        # Este else pertenece al FOR, no al IF.
        # Se ejecuta si el bucle 'for x' termin贸 SIN encontrar un factor.
        print(f"{n} es un n煤mero primo")
```

#### 3. **Desarrollo:**

Es confuso porque la palabra `else` sugiere "si no". Aqu铆 pi茅nsalo como un **"si no hubo break"**.

- Se usa mucho para b煤squedas: Buscas algo en un bucle, si lo encuentras haces `break`. Si el bucle termina y no hiciste `break` (no lo encontraste), se ejecuta el `else`.
- Es similar al `else` en un bloque `try` (se ejecuta si no hubo excepci贸n).

 **Espec铆fico**: Muy 煤til para algoritmos de b煤squeda, pero raro de ver para principiantes.

## G - Sentencia `pass` []

#### 1. **Introducci贸n:**

Es una instrucci贸n que no hace nada. Se usa cuando la sintaxis de Python requiere que escribas algo, pero t煤 no quieres que el programa haga nada.

#### 2. **Ejemplo:**

```python
while True:
    pass  # Espera ocupada (Busy-wait) hasta que interrumpas con Ctrl+C

class MiClaseVacia:
    pass # Para crear una clase m铆nima sin c贸digo a煤n

def funcion_pendiente():
    pass # "TODO: Implementar esto luego"
```

#### 3. **Desarrollo:**

Python no permite bloques vac铆os (como `{}` en otros lenguajes). Si defines una funci贸n o un `if`, tienes que poner algo dentro. `pass` es ese "algo" que le dice a Python "ignora esto y sigue".

 **Espec铆fico**: til como "placeholder" (marcador de posici贸n) mientras programas.

## H - Sentencia `match` (B谩sico) []

#### 1. **Introducci贸n:**

Toma una expresi贸n y compara su valor con varios patrones sucesivos. Es similar al `switch` de C o Java, pero m谩s potente.

#### 2. **Ejemplo:**

```python
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Error desconocido" # El '_' es un comod铆n (wildcard)
```

#### 3. **Desarrollo:**

Solo se ejecuta el primer patr贸n que coincida.

- **`case _:`**: Es el equivalente al `default` en otros lenguajes. Coincide con todo lo que no haya coincidido antes.

 **Importante**: Introducido recientemente en Python, es la forma moderna de manejar m煤ltiples condiciones sobre una misma variable.

## I - `match` (Avanzado: Patrones y Clases) []

#### 1. **Introducci贸n:**

`match` no solo compara valores, puede "desempaquetar" estructuras de datos, verificar tipos y asignar variables al vuelo.

#### 2. **Ejemplo:**

```python
# 1. Combinar opciones con | (OR)
case 401 | 403 | 404:
    return "No permitido"

# 2. Desempaquetado (Binding)
# point es una tupla (x, y)
match point:
    case (0, 0):
        print("Origen")
    case (0, y): # Coincide si x es 0, y asigna el segundo valor a la variable 'y'
        print(f"Eje Y, valor={y}")
    case (x, y):
        print(f"Punto en {x}, {y}")

# 3. Clases y Guardas (if)
match punto_obj:
    case Point(x=x, y=y) if x == y: # Captura x e y, Y ADEMS verifica si son iguales
        print(f"En la diagonal: {x}")
```

#### 3. **Desarrollo:**

- **Captura**: `case (0, y)` no solo verifica que el primero sea 0, sino que crea una variable `y` con el valor del segundo elemento.
- **Clases**: Puedes verificar si un objeto es de una clase espec铆fica (`case Point(x=1, y=var):`) y extraer sus atributos.
- **Guardas**: El `if` despu茅s del `case` a帽ade una condici贸n extra l贸gica.

 **Espec铆fico**: Extremadamente potente para procesar estructuras de datos complejas o 谩rboles de decisi贸n.

## J - Definici贸n de Funciones (`def`) []

#### 1. **Introducci贸n:**

Permite encapsular c贸digo para reutilizarlo. Se usa la palabra clave `def`.

#### 2. **Ejemplo:**

```python
def fib(n):    # nombre y par谩metros
    """Imprime la serie Fibonacci hasta n.""" # Docstring (documentaci贸n)
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

fib(2000) # Llamada a la funci贸n
```

#### 3. **Desarrollo:**

- La primera l铆nea puede ser un string (Docstring) para documentar.
- Crea un nuevo **谩mbito (scope)** local. Las variables creadas dentro de la funci贸n mueren cuando la funci贸n termina.

 **Fundamental**: La base de la programaci贸n estructurada.

## K - mbito de Variables (Scope) []

#### 1. **Introducci贸n:**

Entender d贸nde "viven" tus variables. Las variables dentro de una funci贸n son "locales", las de fuera son "globales".

#### 2. **Ejemplo:**

```python
variable_global = 10

def mi_funcion():
    variable_local = 5
    # Puedo LEER la global
    print(variable_global)
    # Pero NO puedo asignarle valor directamente (crear铆a una nueva local)
    # variable_global = 20  <-- Esto crear铆a una variable local nueva llamada igual

mi_funcion()
# print(variable_local) <-- ERROR: variable_local no existe aqu铆 fuera
```

#### 3. **Desarrollo:**

- **Lectura**: Python busca primero en local, luego en las funciones que la envuelven, luego en global, y finalmente en built-ins (como `len`).
- **Escritura**: Si asignas (`x = 1`) dentro de una funci贸n, Python asume que es una variable local nueva, a menos que uses `global x`.
- **Paso por valor**: Los argumentos se pasan por valor (donde el valor es una referencia al objeto). Si pasas una lista y la modificas dentro (con `.append`), el cambio se ve fuera. Si reasignas la variable (`lista = []`), el cambio NO se ve fuera.

 **Importante**: Fuente com煤n de errores al intentar modificar configuraciones globales desde funciones.

## L - Retorno de valores (`return` y `None`) []

#### 1. **Introducci贸n:**

Todas las funciones en Python devuelven algo. Si no usas `return`, devuelven `None`.

#### 2. **Ejemplo:**

```python
def suma(a, b):
    return a + b  # Devuelve el resultado y termina la funci贸n

def saludo():
    print("Hola")
    # No hay return expl铆cito

resultado = saludo()
print(resultado) # Imprime: None
```

#### 3. **Desarrollo:**

- `return` sin argumentos devuelve `None`.
- Llegar al final de la funci贸n sin `return` devuelve `None`.
- `None` es un valor real (un objeto) que significa "ausencia de valor".

 **Fundamental**: Necesario para sacar datos procesados de tus funciones.

## M - Argumentos con valor por defecto (y su trampa) []

#### 1. **Introducci贸n:**

Puedes hacer que ciertos argumentos sean opcionales d谩ndoles un valor inicial. Pero cuidado si ese valor es mutable (como una lista).

#### 2. **Ejemplo:**

```python
def preguntar(mensaje, intentos=4): # intentos es opcional, por defecto 4
    pass

# LA TRAMPA DE LOS MUTABLES
# Malo: El valor por defecto se eval煤a UNA SOLA VEZ al definir la funci贸n.
def agregar_malo(a, L=[]):
    L.append(a)
    return L

print(agregar_malo(1)) # [1]
print(agregar_malo(2)) # [1, 2] 隆Sorpresa! Comparte la misma lista L

# Bueno: Usar None como centinela
def agregar_bueno(a, L=None):
    if L is None:
        L = [] # Crea una lista nueva cada vez
    L.append(a)
    return L
```

#### 3. **Desarrollo:**

Si usas una lista o diccionario como valor por defecto, ese objeto se crea **una vez** cuando Python lee la definici贸n de la funci贸n, y se reutiliza en todas las llamadas.

- **Soluci贸n**: Usa `None` como valor por defecto y crea el objeto mutable dentro de la funci贸n.

 **Importante**: Es la "novatada" cl谩sica de Python. Apr茅ndela y ah贸rrate horas de depuraci贸n.

## N - Argumentos por palabra clave (Keyword Arguments) []

#### 1. **Introducci贸n:**

Puedes llamar a una funci贸n diciendo expl铆citamente qu茅 valor va a qu茅 par谩metro, sin importar el orden.

#### 2. **Ejemplo:**

```python
def loro(voltaje, estado='muerto', accion='explotar'):
    print(f"Este loro no va a {accion} con {voltaje} voltios. Est谩 {estado}.")

# Llamadas v谩lidas
loro(1000)
loro(voltaje=1000)
loro(accion='VOOOOM', voltaje=1000000) # Orden cambiado
loro('mil', estado='empujando las margaritas') # Posicional + Keyword
```

#### 3. **Desarrollo:**

- Los argumentos posicionales deben ir **antes** que los de palabra clave.
- No puedes pasar valor al mismo argumento dos veces.

 **Importante**: Hace el c贸digo mucho m谩s legible (`func(is_active=True)` es m谩s claro que `func(True)`).

## O - Listas de argumentos arbitrarios (`*args` y `**kwargs`) []

#### 1. **Introducci贸n:**

驴Y si no sabes cu谩ntos argumentos te van a pasar? Usa `*` para tuplas (posicionales) y `**` para diccionarios (palabras clave).

#### 2. **Ejemplo:**

```python
# *arguments recibe una tupla con todo lo posicional extra
# **keywords recibe un diccionario con todo lo nombrado extra
def tienda_queso(tipo, *arguments, **keywords):
    print("Tipo:", tipo)
    for arg in arguments: print(arg)
    for kw in keywords: print(kw, ":", keywords[kw])

tienda_queso("Limburger",
             "Es muy l铆quido", "Huele fuerte", # Van a *arguments
             cliente="Juan", vendedor="Miguel") # Van a **keywords
```

#### 3. **Desarrollo:**

- `*name`: Recoge argumentos sobrantes en una **Tupla**.
- `**name`: Recoge argumentos nombrados sobrantes en un **Diccionario**.
- `*` debe ir antes que `**`.

 **Espec铆fico**: Muy usado en decoradores o funciones que envuelven a otras.

## P - Par谩metros Especiales (`/` y `*`) []

#### 1. **Introducci贸n:**

Puedes obligar a que ciertos par谩metros sean **solo posicionales** o **solo por palabra clave** usando `/` y `*` como separadores en la definici贸n.

#### 2. **Ejemplo:**

```python
def f(pos1, pos2, /, pos_o_kwd, *, kwd1, kwd2):
    pass
```

- **`pos1`, `pos2`**: A la izquierda de `/`. **SOLO Posicionales**. No puedes llamarlos por nombre (`pos1=...` dar铆a error).
- **`pos_o_kwd`**: En el medio. Puedes usar posici贸n o nombre.
- **`kwd1`, `kwd2`**: A la derecha de `*`. **SOLO Keyword**. Debes llamarlos por nombre obligatoriamente.

#### 3. **Desarrollo:**

- Usa `/` (Posicional-only) cuando el nombre del par谩metro no importa o quieres evitar conflictos con `**kwargs`.
- Usa `*` (Keyword-only) cuando quieres forzar claridad (ej: `calcular(..., redondear=True)`).

 **Espec铆fico**: til para dise帽ar APIs robustas y bibliotecas.

## Q - Desempaquetado de Argumentos []

#### 1. **Introducci贸n:**

Lo inverso a lo anterior. Tienes los datos en una lista o diccionario y quieres pas谩rselos a una funci贸n que espera argumentos separados.

#### 2. **Ejemplo:**

```python
args = [3, 6]
list(range(*args)) # Equivale a range(3, 6)

d = {"voltaje": "cuatro millones", "accion": "VOOM"}
loro(**d) # Equivale a loro(voltaje="...", accion="...")
```

#### 3. **Desarrollo:**

- `*lista`: "Explota" la lista en argumentos posicionales.
- `**diccionario`: "Explota" el diccionario en argumentos por palabra clave.

 **Espec铆fico**: Muy 煤til cuando trabajas con datos din谩micos.

## R - Expresiones Lambda []

#### 1. **Introducci贸n:**

Forma de crear funciones peque帽as y an贸nimas (sin nombre) en una sola l铆nea.

#### 2. **Ejemplo:**

```python
# Funci贸n normal
def suma(a, b): return a + b

# Lambda equivalente
suma_lambda = lambda a, b: a + b

# Uso com煤n: como argumento para otra funci贸n (ej: ordenar)
pares = [(1, 'uno'), (2, 'dos'), (3, 'tres')]
# Ordenar por el segundo elemento de la tupla (el texto)
pares.sort(key=lambda pair: pair[1])
```

#### 3. **Desarrollo:**

Est谩n restringidas a una sola expresi贸n. Son "az煤car sint谩ctico" para definir funciones simples al vuelo.

 **Espec铆fico**: til para funciones de "usar y tirar" en `sort`, `map`, `filter`.

## S - Convenciones de Docstrings []

#### 1. **Introducci贸n:**

El texto que explica qu茅 hace tu funci贸n. Debe ser la primera l铆nea del cuerpo.

#### 2. **Ejemplo:**

```python
def mi_funcion():
    """Hace nada, pero lo documenta.

    Aqu铆 ir铆a una explicaci贸n m谩s detallada si fuera necesaria.
    """
    pass

print(mi_funcion.__doc__)
```

#### 3. **Desarrollo:**

- Primera l铆nea: Resumen corto. Empieza con may煤scula, termina con punto.
- Segunda l铆nea: En blanco.
- Resto: Descripci贸n detallada.
- La indentaci贸n se maneja autom谩ticamente por herramientas de documentaci贸n.

 **Importante**: Escribir buenos docstrings es se帽al de un programador profesional.

## T - Anotaciones de Funci贸n (Type Hints) []

#### 1. **Introducci贸n:**

Metadatos opcionales para indicar qu茅 tipos de datos espera y devuelve la funci贸n. Python los ignora al ejecutar, pero ayudan a los programadores y editores de c贸digo.

#### 2. **Ejemplo:**

```python
# Espera un string (ham), un string opcional (eggs), y devuelve un string
def f(ham: str, eggs: str = 'eggs') -> str:
    return ham + ' and ' + eggs
```

#### 3. **Desarrollo:**

Se guardan en el atributo `__annotations__`. No afectan el rendimiento ni obligan a cumplir el tipo (Python sigue siendo din谩mico), pero son vitales para herramientas de chequeo est谩tico.

 **Espec铆fico**: Cada vez m谩s com煤n en proyectos grandes para evitar errores de tipo.

## U - Estilo de C贸digo (PEP 8) []

#### 1. **Introducci贸n:**

El manual de etiqueta de Python. C贸digo que funciona pero se ve feo, es dif铆cil de mantener.

#### 2. **Resumen de reglas clave:**

- **Indentaci贸n**: Usa **4 espacios**, NO tabuladores.
- **Longitud de l铆nea**: M谩ximo 79 caracteres (para ver varias ventanas a la vez).
- **L铆neas en blanco**: Separa funciones y clases con l铆neas vac铆as.
- **Comentarios**: En su propia l铆nea si es posible.
- **Espacios**: `a = f(1, 2) + g(3, 4)` (espacios alrededor de operadores y tras comas).
- **Nombres**:
  - `CamelCase` para Clases (`MiClase`).
  - `snake_case` para funciones y m茅todos (`mi_funcion`).
- **Codificaci贸n**: UTF-8 (por defecto). Usa ingl茅s para identificadores si es posible.

 **Importante**: Seguir PEP 8 hace que tu c贸digo parezca escrito por un experto y facilita que otros lo lean.
