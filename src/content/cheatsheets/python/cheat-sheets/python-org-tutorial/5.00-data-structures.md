---
title: "5 - Estructuras de Datos en Python"
description: "Gu√≠a detallada sobre Listas, Tuplas, Sets, Diccionarios y t√©cnicas de control de flujo"
tags: ["python", "data structures", "lists", "tuples", "sets", "dictionaries"]
prompt-version: cheat-sheet-generator-1.1
---

# PASO 0: √çndice de Conceptos

Aqu√≠ tienes la lista de temas que vamos a desglosar para asegurarnos de que no se nos escape nada del texto original:

1.  **M√©todos de Listas (Modificaci√≥n):** `append`, `extend`, `insert`, `remove`, `pop`, `clear`.
2.  **M√©todos de Listas (Informaci√≥n y Orden):** `index`, `count`, `sort`, `reverse`, `copy`.
3.  **Listas como Pilas (Stacks):** El concepto LIFO.
4.  **Listas como Colas (Queues) vs. `deque`:** El problema de eficiencia y la soluci√≥n correcta.
5.  **List Comprehensions (B√°sico):** Sintaxis para crear listas concisas.
6.  **List Comprehensions (Avanzado):** L√≥gica anidada y matrices.
7.  **La sentencia `del`:** Borrar por √≠ndice vs. borrar por valor.
8.  **Tuplas (Definici√≥n e Inmutabilidad):** Qu√© son y la trampa de la tupla de un solo elemento.
9.  **Empaquetado y Desempaquetado de Secuencias:** Asignaci√≥n m√∫ltiple.
10. **Sets (Conjuntos):** Elementos √∫nicos y operaciones matem√°ticas.
11. **Diccionarios (B√°sico):** Pares clave-valor y restricciones de las claves.
12. **Diccionarios (T√©cnicas de uso):** `get`, `del`, constructores y comprensiones.
13. **T√©cnicas de Iteraci√≥n (Looping):** `items`, `enumerate`, `zip`, `reversed`, `sorted`.
14. **Condiciones Avanzadas:** Operadores `in`, `is`, encadenamiento y cortocircuito (short-circuit).
15. **Comparaci√≥n de Secuencias:** Orden lexicogr√°fico.

---

## A - M√©todos de Listas: Agregando y Quitando Cosas [üî¥]

#### 1. Introducci√≥n:

Las listas en Python son como mochilas donde puedes meter y sacar cosas. Aqu√≠ veremos las herramientas principales para **modificar** el contenido de esa mochila.

#### 2. Ejemplo:

```python
frutas = ['naranja', 'manzana']

# 1. append(x): Agrega al final
frutas.append('pera')
# ['naranja', 'manzana', 'pera']

# 2. extend(iterable): Pega otra lista al final
frutas.extend(['uva', 'kiwi'])
# ['naranja', 'manzana', 'pera', 'uva', 'kiwi']

# 3. insert(i, x): Mete algo en una posici√≥n espec√≠fica (empuja el resto)
frutas.insert(0, 'cereza')
# ['cereza', 'naranja', 'manzana', 'pera', 'uva', 'kiwi']

# 4. remove(x): Busca el PRIMER 'x' y lo borra. Si no est√°, da error.
frutas.remove('manzana')

# 5. pop([i]): Saca y DEVUELVE el elemento en la posici√≥n i (o el √∫ltimo si no das i)
ultima = frutas.pop() # Saca 'kiwi'
primera = frutas.pop(0) # Saca 'cereza'

# 6. clear(): Borra todo
frutas.clear()
# []
```

#### 3. Desarrollo:

Es vital entender que la mayor√≠a de estos m√©todos (como `append`, `insert`, `remove`) **no devuelven nada** (retornan `None`). Modifican la lista "in place" (en el mismo lugar).

- **La trampa del principiante:** No hagas `mi_lista = mi_lista.append(x)`, porque `mi_lista` se convertir√° en `None`. Simplemente haz `mi_lista.append(x)`.

üî¥ **Fundamental:** Sin estos m√©todos no puedes manipular datos din√°micos en Python. Son el ABC.

## B - M√©todos de Listas: Buscando y Ordenando [üü°]

#### 1. Introducci√≥n:

A veces no quieres cambiar la lista, sino preguntarle cosas (¬ød√≥nde est√° X?, ¬øcu√°ntos X hay?) o cambiar su orden visual.

#### 2. Ejemplo:

```python
numeros = [66, 1, 333, 1, 1234.5]

# 1. count(x): ¬øCu√°ntas veces aparece x?
conteo = numeros.count(1) # Devuelve 2

# 2. index(x, [start, end]): ¬øEn qu√© posici√≥n est√° el primer x?
posicion = numeros.index(333) # Devuelve 2
# numeros.index(999) dar√≠a un ValueError porque no existe

# 3. sort(): Ordena la lista (cambia la original)
numeros.sort()
# [1, 1, 66, 333, 1234.5]

# 4. reverse(): Invierte el orden (el √∫ltimo pasa a ser primero)
numeros.reverse()

# 5. copy(): Crea una copia superficial (shallow copy)
copia_numeros = numeros.copy()
```

#### 3. Desarrollo:

- **`sort` vs `sorted()`:** `lista.sort()` ordena la lista original y no devuelve nada. La funci√≥n `sorted(lista)` (que veremos m√°s adelante) crea una _nueva_ lista ordenada y deja la original intacta.
- **`index`:** Puedes decirle d√≥nde empezar a buscar (`start`) y d√≥nde terminar (`end`) para buscar en sub-secciones.

üü° **Importante:** Muy usados para l√≥gica de control y presentaci√≥n de datos.

## C - Listas como Pilas (Stacks) [üî¥]

#### 1. Introducci√≥n:

Una "Pila" sigue el principio **LIFO** (Last-In, First-Out): el √∫ltimo plato que pones en la pila es el primero que lavas.

#### 2. Ejemplo:

```python
stack = [3, 4, 5]

# Apilar (Push) -> Usamos append()
stack.append(6)
stack.append(7) # El 7 es el √∫ltimo en entrar

# Desapilar (Pop) -> Usamos pop() sin argumentos
ultimo = stack.pop() # Devuelve 7
siguiente = stack.pop() # Devuelve 6
```

#### 3. Desarrollo:

Las listas de Python est√°n optimizadas para esto. Usar `append` y `pop` (sin √≠ndice) es muy r√°pido y eficiente. No necesitas importar nada extra para hacer una pila.

üî¥ **Fundamental:** Es la estructura de datos m√°s b√°sica en algoritmos.

## D - Listas como Colas (Queues) vs. `deque` [üîµ]

#### 1. Introducci√≥n:

Una "Cola" sigue el principio **FIFO** (First-In, First-Out): como una fila en el supermercado, el primero que llega es el primero en ser atendido.

#### 2. Ejemplo:

```python
# ‚ùå FORMA INCORRECTA (O LENTA) CON LISTAS
cola = ["Eric", "John"]
cola.insert(0, "Michael") # Lento: tiene que mover a Eric y John
cola.pop()

# ‚úÖ FORMA CORRECTA CON DEQUE
from collections import deque
cola_rapida = deque(["Eric", "John", "Michael"])

cola_rapida.append("Terry")    # Llega Terry
cola_rapida.append("Graham")   # Llega Graham

primero_en_irse = cola_rapida.popleft() # Se va Eric (R√°pido)
```

#### 3. Desarrollo:

**¬øPor qu√© no usar listas normales?**
Insertar o sacar elementos del _principio_ de una lista (`insert(0, x)` o `pop(0)`) es **lento** porque Python tiene que desplazar todos los dem√°s elementos en memoria una posici√≥n.
`collections.deque` est√° dise√±ada espec√≠ficamente para agregar y quitar cosas de ambos extremos r√°pidamente.

üîµ **Espec√≠fico:** √ösalo siempre que necesites una cola real. Si usas una lista normal para una cola grande, tu programa se arrastrar√°.

## E - List Comprehensions (Comprensi√≥n de Listas) [üü°]

#### 1. Introducci√≥n:

Es una forma elegante y compacta de crear una nueva lista aplicando una operaci√≥n a cada elemento de otra secuencia. Es "Pythonic" (la forma recomendada de hacerlo).

#### 2. Ejemplo:

```python
# Forma "vieja" (bucle for cl√°sico)
cuadrados = []
for x in range(10):
    cuadrados.append(x**2)

# Forma "List Comprehension"
# Sintaxis: [expresion for item in iterable]
cuadrados = [x**2 for x in range(10)]

# Con filtro (if)
# Solo pares:
pares = [x for x in range(10) if x % 2 == 0]
```

#### 3. Desarrollo:

Piensa en la frase: "Quiero `x**2` **para cada** `x` **en** el rango, **si** cumple tal condici√≥n".
Es m√°s legible y conciso que usar `map()` y `filter()`.

üü° **Importante:** Ver√°s esto en casi todo el c√≥digo Python moderno.

## F - List Comprehensions Anidadas [üîµ]

#### 1. Introducci√≥n:

Puedes poner una comprensi√≥n de lista dentro de otra. √ötil para trabajar con matrices (listas de listas).

#### 2. Ejemplo:

```python
matriz = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]

# Transponer filas y columnas (cambiar filas por columnas)
transpuesta = [[fila[i] for fila in matriz] for i in range(4)]
# Resultado: [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

# Truco PRO: Usar zip() para lo mismo
transpuesta_zip = list(zip(*matriz))
```

#### 3. Desarrollo:

La comprensi√≥n interna se eval√∫a en el contexto del `for` que la sigue. Aunque es potente, si se vuelve muy compleja, es mejor usar bucles normales o funciones integradas como `zip()` para mantener la legibilidad.

üîµ **Espec√≠fico:** Muy √∫til en ciencia de datos o matem√°ticas sin librer√≠as externas.

## G - La sentencia `del` [üü°]

#### 1. Introducci√≥n:

`del` es una instrucci√≥n directa para eliminar cosas. A diferencia de `pop()`, no devuelve el valor eliminado. A diferencia de `remove()`, borra por **√≠ndice**, no por valor.

#### 2. Ejemplo:

```python
a = [-1, 1, 66.25, 333, 333, 1234.5]

del a[0]    # Borra el primer elemento (-1)
del a[2:4]  # Borra un rango (slice)
del a[:]    # Borra todo (equivalente a clear())

# Tambi√©n borra variables completas
del a
# print(a) -> Error, 'a' ya no existe
```

#### 3. Desarrollo:

`del` es una sentencia de Python, no un m√©todo de lista. Sirve para borrar elementos de listas, claves de diccionarios, o variables enteras del espacio de nombres.

üü° **Importante:** Es la forma est√°ndar de eliminar variables o partes de estructuras por su posici√≥n.

## H - Tuplas y Secuencias [üî¥]

#### 1. Introducci√≥n:

Las tuplas son secuencias como las listas, pero son **inmutables**. Una vez creadas, no puedes cambiar, a√±adir ni borrar sus elementos.

#### 2. Ejemplo:

```python
# Se definen con comas (los par√©ntesis son opcionales pero recomendados)
t = 12345, 54321, 'hola!'
# t es (12345, 54321, 'hola!')

# Acceso igual que listas
print(t[0]) # 12345

# Inmutabilidad
# t[0] = 88888  -> ‚ùå ERROR: TypeError

# Pueden contener objetos mutables
v = ([1, 2, 3], [3, 2, 1]) # Una tupla con listas adentro
```

#### 3. Desarrollo:

**¬øLista vs Tupla?**

- **Listas:** Mutables, homog√©neas (usualmente cosas del mismo tipo), para iterar.
- **Tuplas:** Inmutables, heterog√©neas (cosas distintas), para estructura de datos fija.

**‚ö†Ô∏è LA TRAMPA DEL SINGLETON:**
Para crear una tupla de un solo elemento, **necesitas una coma final**.

- `x = (5)` -> `x` es un n√∫mero entero `int`.
- `x = (5,)` -> `x` es una tupla `tuple`.

üî¥ **Fundamental:** Entender la inmutabilidad es clave para evitar errores y usar diccionarios (las tuplas pueden ser claves, las listas no).

## I - Empaquetado y Desempaquetado [üü°]

#### 1. Introducci√≥n:

Python permite asignar m√∫ltiples variables a la vez bas√°ndose en la posici√≥n de los elementos en una secuencia.

#### 2. Ejemplo:

```python
t = 12345, 54321, 'hola!' # Empaquetado (Packing)

x, y, z = t # Desempaquetado (Unpacking)
# x vale 12345
# y vale 54321
# z vale 'hola!'
```

#### 3. Desarrollo:

Requiere que el n√∫mero de variables a la izquierda sea **exactamente igual** al n√∫mero de elementos en la secuencia. Funciona con cualquier secuencia (listas, tuplas, strings).

üü° **Importante:** Hace el c√≥digo muy limpio, especialmente al retornar m√∫ltiples valores desde una funci√≥n.

## J - Sets (Conjuntos) [üîµ]

#### 1. Introducci√≥n:

Un `set` es una colecci√≥n **desordenada** y **sin elementos duplicados**. Ideal para verificar pertenencia ("¬øest√° X aqu√≠?") y eliminar repetidos.

#### 2. Ejemplo:

```python
canasta = {'manzana', 'naranja', 'manzana', 'pera'}
print(canasta)
# {'naranja', 'manzana', 'pera'} (Elimin√≥ la manzana duplicada)

# Verificar pertenencia (S√∫per r√°pido)
'naranja' in canasta # True

# Operaciones matem√°ticas
a = set('abracadabra')
b = set('alacazam')

print(a - b) # Diferencia (letras en a pero no en b)
print(a | b) # Uni√≥n (letras en a O en b)
print(a & b) # Intersecci√≥n (letras en a Y en b)
print(a ^ b) # Diferencia sim√©trica (en a o b, pero no ambos)
```

#### 3. Desarrollo:

**‚ö†Ô∏è LA TRAMPA DEL SET VAC√çO:**

- `{}` crea un **diccionario** vac√≠o, NO un set.
- Para crear un set vac√≠o, debes usar `set()`.

üîµ **Espec√≠fico:** Fundamental para matem√°ticas de conjuntos y optimizaci√≥n de b√∫squedas (buscar en un set es mucho m√°s r√°pido que en una lista).

## K - Diccionarios (Dictionaries) [üî¥]

#### 1. Introducci√≥n:

Son colecciones de pares **Clave: Valor**. A diferencia de las secuencias que usan √≠ndices num√©ricos, aqu√≠ usas una "clave" (key) para encontrar un "valor".

#### 2. Ejemplo:

```python
tel = {'jack': 4098, 'sape': 4139}
tel['guido'] = 4127 # Agregar nuevo par

print(tel['jack']) # 4098

del tel['sape'] # Borrar par
list(tel) # ['jack', 'guido'] (Lista de claves)
'guido' in tel # True (Verificar si existe la clave)
```

#### 3. Desarrollo:

**Reglas de las Claves:**

- Deben ser **inmutables** (strings, n√∫meros, tuplas).
- NO puedes usar listas como claves (porque son mutables).
- Las claves deben ser √∫nicas dentro del diccionario.

üî¥ **Fundamental:** Es la estructura de datos m√°s poderosa y flexible de Python.

## L - T√©cnicas de Diccionarios y Constructores [üü°]

#### 1. Introducci√≥n:

Formas seguras de acceder a datos y maneras alternativas de crear diccionarios.

#### 2. Ejemplo:

```python
d = {'a': 1, 'b': 2}

# Acceso seguro con get()
# d['c'] dar√≠a KeyError
valor = d.get('c', 'No existe') # Devuelve 'No existe' (o None por defecto)

# Constructor dict()
d2 = dict([('sape', 4139), ('guido', 4127)])
d3 = dict(sape=4139, guido=4127) # Con keywords (si las claves son strings simples)

# Dict Comprehension
cuadrados = {x: x**2 for x in (2, 4, 6)}
# {2: 4, 4: 16, 6: 36}
```

#### 3. Desarrollo:

Usar `get()` es la pr√°ctica recomendada cuando no est√°s 100% seguro de que la clave existe, evitando que tu programa se rompa con un error.

üü° **Importante:** `get()` te salvar√° de muchos dolores de cabeza.

## M - T√©cnicas de Iteraci√≥n (Looping) [üü°]

#### 1. Introducci√≥n:

Python ofrece herramientas para recorrer datos de forma inteligente, obteniendo √≠ndices, claves y valores simult√°neamente.

#### 2. Ejemplo:

```python
# 1. items(): Clave y Valor al mismo tiempo
caballeros = {'gallahad': 'el puro', 'robin': 'el valiente'}
for k, v in caballeros.items():
    print(k, v)

# 2. enumerate(): √çndice y Valor
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v) # 0 tic, 1 tac...

# 3. zip(): Recorrer dos listas en paralelo
preguntas = ['nombre', 'color']
respuestas = ['lancelot', 'azul']
for p, r in zip(preguntas, respuestas):
    print(f"¬øCual es tu {p}? {r}.")

# 4. reversed() y sorted(): Sin tocar la original
for i in reversed(range(1, 10, 2)): pass
for f in sorted(set(['manzana', 'pera', 'manzana'])): pass # √önicos y ordenados
```

#### 3. Desarrollo:

**Consejo de seguridad:** Nunca modifiques una lista mientras iteras sobre ella. Es mejor crear una lista nueva.

- _Mal:_ `for x in lista: if x > 5: lista.remove(x)`
- _Bien:_ `nueva = [x for x in lista if not x > 5]`

üü° **Importante:** Estas funciones (`enumerate`, `zip`) distinguen a un programador Python novato de uno intermedio.

## N - Condiciones y Comparaciones Avanzadas [üîµ]

#### 1. Introducci√≥n:

Las condiciones en `if` y `while` pueden ser mucho m√°s que simples `a > b`.

#### 2. Ejemplo:

```python
a, b, c = 1, 2, 2

# Encadenamiento
if a < b == c: # Verifica si a < b Y ADEM√ÅS b == c
    pass

# Operadores booleanos y Short-circuit
# Si A es falso, no se molesta en evaluar B
if (a > 10) and (b/0 == 0):
    pass # No da error de divisi√≥n por cero porque a > 10 es False y para ah√≠.

# Asignaci√≥n en expresi√≥n (Walrus operator :=)
if (n := len([1,2,3])) > 2:
    print(f"La lista es larga, tiene {n} elementos")
```

#### 3. Desarrollo:

- `in` / `not in`: Test de pertenencia.
- `is` / `is not`: Compara si son **el mismo objeto en memoria**, no solo si tienen el mismo valor.
- **Short-circuit:** `A and B` se detiene si A es falso. `A or B` se detiene si A es verdadero.

üîµ **Espec√≠fico:** El operador Walrus (`:=`) es √∫til pero √∫salo con moderaci√≥n para no afectar la legibilidad.

## O - Comparando Secuencias [üîµ]

#### 1. Introducci√≥n:

Puedes comparar listas con listas, tuplas con tuplas, etc. Python usa el orden **lexicogr√°fico** (como el orden alfab√©tico en un diccionario).

#### 2. Ejemplo:

```python
(1, 2, 3) < (1, 2, 4) # True (3 es menor que 4)
[1, 2, 3] < [1, 2, 4] # True
'ABC' < 'C' < 'Pascal' < 'Python' # True
(1, 2, 3, 4) < (1, 2, 4) # True (compara el 3 con el 4, ignora el resto)
```

#### 3. Desarrollo:

Compara elemento por elemento. En cuanto encuentra una diferencia, decide qui√©n es mayor o menor y se detiene. Si una secuencia es igual a la otra pero m√°s corta, la m√°s corta es "menor".
**Nota:** No puedes comparar tipos incompatibles (ej. n√∫mero con string) a menos que tengan m√©todos de comparaci√≥n definidos.

üîµ **Espec√≠fico:** √ötil para ordenar listas de datos complejos.
