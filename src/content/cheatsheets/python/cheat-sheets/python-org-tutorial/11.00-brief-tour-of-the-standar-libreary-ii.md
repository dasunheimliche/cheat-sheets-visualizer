---
title: "11.2 - Tour de la Librer칤a Est치ndar - Parte II"
description: "Herramientas avanzadas para necesidades profesionales: formateo, hilos, binarios y estructuras de datos."
tags: ["python", "standard library", "advanced"]
prompt-version: cheat-sheet-generator-1.1
---

## A - reprlib: El Resumidor de Datos [游댯]

#### 1. **Introducci칩n:**

Es una versi칩n de `repr()` dise침ada para protegerte de inundar tu consola cuando imprimes objetos gigantescos o muy profundos, recortando la salida autom치ticamente.

#### 2. **Ejemplo:**

```python
import reprlib
# Imagina un set gigante con muchas letras
mi_set_gigante = set('supercalifragilisticoespialidoso')

# repr() normal imprimir칤a TODO. reprlib lo recorta:
print(reprlib.repr(mi_set_gigante))
# Salida: "{'a', 'c', 'd', 'e', 'f', 'g', ...}"
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: 칔salo cuando est칠s depurando estructuras de datos que podr칤an tener miles de elementos. En lugar de congelar tu terminal imprimiendo 10,000 items, `reprlib` te muestra el principio y pone puntos suspensivos `...` al final. Es un salvavidas para logs de depuraci칩n.

## B - pprint: Impresi칩n Legible para Humanos [游리]

#### 1. **Introducci칩n:**

Significa "Pretty Print" (Impresi칩n Bonita) y sirve para mostrar diccionarios y listas anidadas de forma ordenada, con indentaci칩n y saltos de l칤nea, en lugar de una sola l칤nea ilegible.

#### 2. **Ejemplo:**

```python
import pprint

data_compleja = [[[['negro', 'cian'], 'blanco', ['verde', 'rojo']], [['magenta', 'amarillo'], 'azul']]]

# print(data_compleja) imprimir칤a todo en una l칤nea horrible.
# pprint lo hace legible:
pprint.pprint(data_compleja, width=30)

# Salida:
# [[[['negro', 'cian'],
#    'blanco',
#    ['verde', 'rojo']],
#   [['magenta', 'amarillo'],
#    'azul']]]
```

#### 3. **Desarrollo:**

[游리 Importante]: Si trabajas con JSONs, respuestas de APIs o configuraciones complejas, `pprint` es obligatorio. El int칠rprete entiende la salida, pero lo importante es que _t칰_ la entiendas. El par치metro `width` le dice cu치ndo debe cortar la l칤nea.

## C - textwrap: Ajuste de P치rrafos [游댯]

#### 1. **Introducci칩n:**

Formatea bloques de texto para que se ajusten a un ancho de pantalla espec칤fico, ideal para interfaces de l칤nea de comandos (CLI).

#### 2. **Ejemplo:**

```python
import textwrap
texto = "Este es un texto muy largo que necesita ser ajustado para que se vea bien en una columna estrecha."

# Corta el texto para que no supere los 20 caracteres de ancho
print(textwrap.fill(texto, width=20))

# Salida:
# Este es un texto muy
# largo que necesita
# ser ajustado para
# que se vea bien en
# una columna
# estrecha.
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: Muy 칰til si est치s creando scripts que imprimen ayuda o instrucciones en la terminal y quieres que se vea profesional sin importar el tama침o de la ventana del usuario.

## D - locale: Formatos Culturales (Moneda y N칰meros) [游댯]

#### 1. **Introducci칩n:**

Permite formatear n칰meros y fechas seg칰n las convenciones de un pa칤s espec칤fico (como usar comas para separar miles o puntos para decimales).

#### 2. **Ejemplo:**

```python
import locale
# Configuramos el local a Ingl칠s de EE.UU.
locale.setlocale(locale.LC_ALL, 'English_United States.1252')

x = 1234567.8

# %d para enteros con agrupaci칩n, grouping=True activa las comas
print(locale.format_string("%d", x, grouping=True))
# Salida: '1,234,567'

# Formato moneda (obtiene el s칤mbolo $ autom치ticamente del locale)
conv = locale.localeconv()
print(locale.format_string("%s%.*f", (conv['currency_symbol'], conv['frac_digits'], x), grouping=True))
# Salida: '$1,234,567.80'
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: Es vital si tu aplicaci칩n se usa en diferentes pa칤ses. Ojo: `setlocale` es global para todo el programa, as칤 que ten cuidado si cambias esto en medio de una ejecuci칩n, ya que podr칤a afectar a otras partes del c칩digo.

## E - string.Template: Plantillas para Usuarios Finales [游댯]

#### 1. **Introducci칩n:**

Una forma simplificada de insertar variables en texto usando el s칤mbolo `$`, dise침ada para que los usuarios (no programadores) puedan editar las plantillas sin romper el c칩digo.

#### 2. **Ejemplo:**

```python
from string import Template

# El usuario define esto (usa $variable):
plantilla = Template('Hola ${nombre}, debes $$10 a la causa $causa.')

# T칰 rellenas los datos:
print(plantilla.substitute(nombre='Juan', causa='Pro-Caf칠'))
# Salida: Hola Juan, debes $10 a la causa Pro-Caf칠.
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: A diferencia de las f-strings (`f"{var}"`), `Template` es m치s seguro para cuando la plantilla viene de una fuente externa (como un archivo de configuraci칩n editado por un usuario). Nota c칩mo `$$` se usa para escapar y mostrar un s칤mbolo de d칩lar real.

## F - substitute() vs safe_substitute() [游리]

#### 1. **Introducci칩n:**

Dos formas de rellenar una `Template`: una es estricta y lanza error si faltan datos, la otra es permisiva y deja el marcador tal cual.

#### 2. **Ejemplo:**

```python
t = Template('Devolver $item a $dueno.')
datos = {'item': 'libro'} # Falta 'dueno'

# A) substitute: Lanza error si falta algo (춰P치nico!)
# t.substitute(datos) -> KeyError: 'dueno'

# B) safe_substitute: Ignora lo que falta (춰Calma!)
print(t.safe_substitute(datos))
# Salida: 'Devolver libro a $dueno.'
```

#### 3. **Desarrollo:**

[游리 Importante]:

- Usa **`substitute`** cuando controlar los datos es tu responsabilidad y un dato faltante es un bug.
- Usa **`safe_substitute`** (como en mail-merge o correos masivos) donde es preferible enviar un correo con un "$nombre" sin reemplazar que romper todo el proceso por un dato faltante.

## G - struct: Datos Binarios [游댯]

#### 1. **Introducci칩n:**

Permite convertir (empaquetar/desempaquetar) datos de Python a estructuras binarias tipo C, esencial para leer archivos binarios (como ZIPs o im치genes) o protocolos de red.

#### 2. **Ejemplo:**

```python
import struct

# Imaginemos que leemos 16 bytes de un archivo binario
# '<' = little-endian (orden de bytes est치ndar en PC)
# 'I' = Unsigned Int (4 bytes), 'H' = Unsigned Short (2 bytes)
# Formato: 3 Enteros (I), 2 Shorts (H) = 16 bytes total
data_binaria = b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x05\x00'

campos = struct.unpack('<IIIHH', data_binaria)
print(campos)
# Salida: (1, 2, 3, 4, 5)
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: Es una herramienta de bajo nivel. Los c칩digos (`I`, `H`, `<`) son cr칤pticos pero est치ndar. Si no est치s leyendo archivos binarios crudos creados por otros lenguajes o sistemas, raramente lo usar치s.

## H - threading: Multihilo B치sico [游리]

#### 1. **Introducci칩n:**

Permite ejecutar tareas en paralelo (desacopladas) para que tu programa no se congele mientras espera una operaci칩n lenta (como escribir un archivo grande o descargar algo).

#### 2. **Ejemplo:**

```python
import threading, time

class TareaFondo(threading.Thread):
    def run(self):
        time.sleep(2) # Simula trabajo pesado
        print('춰Tarea en segundo plano terminada!')

fondo = TareaFondo()
fondo.start() # Inicia el hilo aparte
print('El programa principal sigue corriendo...')

fondo.join() # Espera a que el hilo termine
print('Todo listo.')
```

#### 3. **Desarrollo:**

[游리 Importante]: `threading` es genial para mantener la interfaz responsiva (I/O bound). Sin embargo, coordinar hilos que comparten datos es dif칤cil y propenso a errores.

## I - queue vs. Primitivas de Sincronizaci칩n [游댮]

#### 1. **Introducci칩n:**

La forma segura de comunicar hilos. En lugar de usar "candados" (locks) manuales para proteger datos compartidos (que es dif칤cil y peligroso), usa una `Queue` (cola) para pasar mensajes entre hilos.

#### 2. **Ejemplo:**

```python
from queue import Queue
import threading

q = Queue()

def trabajador():
    while True:
        item = q.get() # Espera hasta que haya algo
        if item is None: break
        print(f'Procesando {item}')
        q.task_done()

t = threading.Thread(target=trabajador)
t.start()

q.put("Tarea 1") # Enviar datos de forma segura al hilo
q.put(None)      # Se침al de parada
```

#### 3. **Desarrollo:**

[游댮 Fundamental]: **춰Atenci칩n aqu칤!** El texto hace una distinci칩n cr칤tica. Aunque `threading` tiene herramientas como `Lock` o `Semaphore`, un peque침o error de dise침o puede causar problemas irreproducibles.

- **Mala Pr치ctica:** Intentar sincronizar hilos manualmente con Locks si eres principiante.
- **Buena Pr치ctica:** Usar `queue`. Un hilo produce datos, los mete en la cola, y otro los saca. Es limpio, legible y mucho m치s seguro.

## J - logging: El Reemplazo de print() [游리]

#### 1. **Introducci칩n:**

Un sistema flexible para emitir mensajes de estado, error o depuraci칩n, que permite categorizar la importancia y decidir d칩nde guardar esos mensajes (archivo, email, consola) sin cambiar el c칩digo.

#### 2. **Ejemplo:**

```python
import logging
# Por defecto, solo muestra WARNING o superior
logging.warning('Cuidado: archivo de config no encontrado')
logging.error('Error: Fall칩 la conexi칩n')

# Salida en consola:
# WARNING:root:Cuidado: archivo de config no encontrado
# ERROR:root:Error: Fall칩 la conexi칩n
```

#### 3. **Desarrollo:**

[游리 Importante]: Deja de usar `print()` para depurar errores en producci칩n. `logging` te permite filtrar: puedes activar mensajes `DEBUG` mientras desarrollas y solo dejar `ERROR` cuando el programa est칠 en vivo, todo cambiando una configuraci칩n y no el c칩digo. Niveles: DEBUG, INFO, WARNING, ERROR, CRITICAL.

## K - weakref: Referencias Fantasma [游댯]

#### 1. **Introducci칩n:**

Permite "vigilar" un objeto sin impedir que el recolector de basura lo elimine. 칔til para cach칠s donde quieres guardar un objeto solo si alguien m치s lo est치 usando.

#### 2. **Ejemplo:**

```python
import weakref

class A: pass
obj = A()
d = weakref.WeakValueDictionary()
d['clave'] = obj # No cuenta como una referencia "real"

print(d['clave']) # El objeto existe

del obj # Borramos la referencia real
# Al acceder ahora, d['clave'] ya no existe autom치ticamente
# porque el recolector de basura se llev칩 el objeto.
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: Python borra objetos cuando su "contador de referencias" llega a cero. Si guardas un objeto en una lista normal, el contador sube y nunca se borra. Con `weakref`, no subes el contador. Si el objeto muere en el resto del programa, desaparece de tu `weakref` autom치ticamente.

## L - array: Listas Eficientes y Estrictas [游댯]

#### 1. **Introducci칩n:**

Parecido a una lista, pero solo acepta un tipo de dato (homog칠neo) y ocupa mucho menos memoria. Ideal para millones de n칰meros.

#### 2. **Ejemplo:**

```python
from array import array
# 'H' = unsigned short (2 bytes por n칰mero)
a = array('H', [4000, 10, 700, 22222])
print(sum(a)) # Funciona como lista: 26932
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: Una lista normal de Python (`[1, 2]`) gasta mucha memoria porque cada n칰mero es un objeto entero completo (aprox 16+ bytes). Un `array` los guarda como datos binarios compactos (2 bytes en el ejemplo). 칔salo solo si la memoria es un problema.

## M - collections.deque: La Cola R치pida [游리]

#### 1. **Introducci칩n:**

Una lista optimizada para insertar y sacar elementos por _ambos_ extremos (izquierda y derecha) muy r치pido.

#### 2. **Ejemplo:**

```python
from collections import deque
d = deque(["tarea1", "tarea2"])
d.append("tarea3")      # Agrega al final
d.appendleft("tarea0")  # Agrega al principio (춰R치pido!)
print(d.popleft())      # Saca del principio (춰R치pido!)
# Salida: tarea0
```

#### 3. **Desarrollo:**

[游리 Importante]:

- **Lista normal (`list`):** R치pida al final, pero LENTA si insertas/borras al principio (tiene que mover todo el resto de elementos).
- **Deque:** R치pida en ambos extremos. 칔sala para colas (queues) o b칰squedas "Breadth-First".
- _Desventaja:_ Es m치s lenta que una lista si quieres leer algo en el medio (`d[500]`).

## N - bisect: Listas Siempre Ordenadas [游댯]

#### 1. **Introducci칩n:**

Funciones para insertar elementos en una lista y que esta se mantenga ordenada autom치ticamente, sin tener que llamar a `sort()` cada vez (lo cual ser칤a lento).

#### 2. **Ejemplo:**

```python
import bisect
scores = [100, 200, 400, 500]
# Insertamos 300. bisect busca d칩nde va y lo pone ah칤.
bisect.insort(scores, 300)
print(scores)
# Salida: [100, 200, 300, 400, 500]
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: Es mucho m치s eficiente insertar un elemento en su lugar correcto que agregar al final y reordenar toda la lista gigante una y otra vez.

## O - heapq: El Rey de la Colina (Min-Heap) [游댯]

#### 1. **Introducci칩n:**

Convierte una lista en un "heap" (mont칤culo), una estructura donde el elemento m치s peque침o siempre est치 en la posici칩n 0.

#### 2. **Ejemplo:**

```python
from heapq import heapify, heappop, heappush
data = [1, 3, 5, 7, 9, 2]
heapify(data) # Reorganiza
heappush(data, -5) # Agrega uno nuevo muy peque침o

# Saca los 3 m치s peque침os eficientemente
print([heappop(data) for i in range(3)])
# Salida: [-5, 1, 2]
```

#### 3. **Desarrollo:**

[游댯 Espec칤fico]: 칔til para colas de prioridad (ej: atender tareas urgentes primero). No ordena toda la lista perfectamente, solo garantiza que el que saques (`pop`) sea el menor de todos.

## P - decimal.Decimal vs float: La Trampa del Dinero [游댮]

#### 1. **Introducci칩n:**

`Decimal` ofrece aritm칠tica de punto flotante con precisi칩n exacta, dise침ada para finanzas, mientras que `float` (el nativo de Python) usa binario y tiene errores de redondeo.

#### 2. **Ejemplo:**

```python
from decimal import Decimal

# CASO FLOAT (Binario): Error de precisi칩n
# Calcular 5% de impuesto sobre 70 centavos
res_float = 0.70 * 1.05
print(round(res_float, 2))
# Salida: 0.73 (춰Incorrecto! Deber칤a redondearse a 0.74)

# CASO DECIMAL (Exacto):
res_decimal = Decimal('0.70') * Decimal('1.05')
print(round(res_decimal, 2))
# Salida: 0.74 (춰Correcto!)
```

#### 3. **Desarrollo:**

[游댮 Fundamental]: **쯇or qu칠 elegir uno u otro?**

- **Float:** Es r치pido. 칔salo para f칤sica, gr치ficos o cuando un error de 0.000000001 no importa.
- **Decimal:** Es lento pero exacto. **칔salo SIEMPRE para dinero**.
- **La Trampa:** Los floats binarios no pueden representar exactamente n칰meros como 0.1.
  - `1.00 % 0.10` da `0.09999...` en float.
  - `Decimal('1.00') % Decimal('.10')` da `0.00` (Exacto).
- **Nota:** `Decimal` tambi칠n permite controlar el redondeo legal y la cantidad de d칤gitos significativos.
