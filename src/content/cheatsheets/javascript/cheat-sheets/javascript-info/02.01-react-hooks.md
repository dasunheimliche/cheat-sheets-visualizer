---
title: "React Hooks"
description: "Los hooks m√°s importantes de React con ejemplos visuales"
order: 3
tags: ["react", "hooks", "frontend"]
---

## A - useState: El Estado Local üî¥

#### 1. **Introducci√≥n:**

`useState` te permite a√±adir estado a componentes funcionales. Es el hook m√°s b√°sico y usado de React.

![Diagrama de flujo de useState](https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop)

#### 2. **Ejemplo:**

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Clicks: {count}
    </button>
  );
}
```

**‚Üí** Cada click incrementa el contador y re-renderiza el componente

#### ‚ö†Ô∏è Cuidado con:

Nunca modifiques el estado directamente (`count++`). Siempre usa el setter (`setCount`).

üî¥ **Fundamental**: Sin `useState` no puedes tener componentes interactivos. Es el primer hook que debes dominar.

---

## B - useEffect: Efectos Secundarios üî¥

#### 1. **Introducci√≥n:**

`useEffect` te permite ejecutar c√≥digo despu√©s del render: llamadas a APIs, suscripciones, manipulaci√≥n del DOM, etc.

![Ciclo de vida de useEffect](https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop)

#### 2. **Ejemplo:**

```jsx
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Se ejecuta cuando userId cambia
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => setUser(data));

    // Cleanup (opcional)
    return () => console.log('Limpiando...');
  }, [userId]); // Array de dependencias

  return <div>{user?.name}</div>;
}
```

**‚Üí** Cada vez que `userId` cambia, se hace una nueva petici√≥n

#### ‚ö†Ô∏è Cuidado con:

El array de dependencias vac√≠o `[]` significa "solo al montar". Sin array significa "en cada render".

üî¥ **Fundamental**: Es el hook para sincronizar tu componente con sistemas externos (APIs, DOM, timers).

---

## C - useContext: Estado Global Sin Props üü°

#### 1. **Introducci√≥n:**

`useContext` te permite acceder a datos de un Context sin pasar props manualmente por cada nivel del √°rbol.

![√Årbol de componentes con Context](https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop)

#### 2. **Ejemplo:**

```jsx
// 1. Crear el contexto
const ThemeContext = createContext('light');

// 2. Proveer el valor (arriba en el √°rbol)
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

// 3. Consumir el valor (en cualquier hijo)
function Button() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>Click</button>;
}
```

**‚Üí** `Button` accede al tema sin que `Toolbar` tenga que pasarlo como prop

üü° **Importante**: Ideal para temas, autenticaci√≥n, idioma. No abuses para todo el estado.

---

## D - useMemo y useCallback: Optimizaci√≥n üîµ

#### 1. **Introducci√≥n:**

Memorizan valores (`useMemo`) o funciones (`useCallback`) para evitar rec√°lculos innecesarios en cada render.

#### 2. **Ejemplo:**

```jsx
// useMemo: memoriza el RESULTADO de una funci√≥n
const sortedList = useMemo(() => {
  return items.sort((a, b) => a.price - b.price);
}, [items]);

// useCallback: memoriza la FUNCI√ìN en s√≠
const handleClick = useCallback(() => {
  console.log('Clicked:', id);
}, [id]);
```

**‚Üí** Solo se recalculan cuando cambian las dependencias

#### ‚ö†Ô∏è Cuidado con:

No optimices prematuramente. √ösalos solo cuando tengas problemas de rendimiento reales.

üîµ **Espec√≠fico**: √ötil en listas largas, c√°lculos pesados, o al pasar callbacks a componentes memorizados.
