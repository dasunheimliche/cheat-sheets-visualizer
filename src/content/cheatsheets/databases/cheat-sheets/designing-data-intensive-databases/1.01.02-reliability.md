---
title: "1.1.2 - Confiabilidad en Sistemas de Datos"
description: "Entendiendo qu√© hace que un sistema sea confiable, resiliente y tolerante a fallos."
tags: ["system-design", "reliability", "architecture"]
prompt-version: cheat-sheet-generator-1.1
---

## A - Confiabilidad (Reliability): "Que funcione aunque el mundo arda" [üî¥]

#### 1. **Introducci√≥n:**

No basta con que tu aplicaci√≥n haga lo que se supone que debe hacer; la verdadera confiabilidad significa que **siga funcionando correctamente incluso cuando las cosas salen mal** (errores de usuario, picos de carga o cables desconectados).

#### 2. **Ejemplo:**

Imagina un coche moderno con neum√°ticos "Run-flat".

- **Expectativa:** El coche te lleva del punto A al punto B.
- **Realidad (Algo sale mal):** Pisas un clavo y el neum√°tico se pincha.
- **Confiabilidad:** El coche **no se detiene**; te permite conducir 80km m√°s para llegar al taller, en lugar de dejarte tirado en la autopista.

#### 3. **Desarrollo:**

Para el software, "funcionar correctamente" implica varias cosas a la vez: hacer lo que el usuario espera, tolerar errores del usuario (que toquen donde no deben), aguantar el volumen de datos esperado y prevenir accesos no autorizados. Si logras todo esto mientras el entorno es hostil, tu sistema es confiable.

üî¥ **Fundamental:** Es la base de la pir√°mide. Si tu sistema no es confiable, no importa qu√© tan r√°pido o escalable sea; si no funciona cuando se necesita, es in√∫til.

---

## B - Fault vs. Failure: "El componente roto vs. El sistema ca√≠do" [üî¥]

#### 1. **Introducci√≥n:**

Aqu√≠ hay una trampa ling√º√≠stica com√∫n. Un **Fault (Falla)** es cuando una pieza interna se desv√≠a de su especificaci√≥n. Un **Failure (Fallo)** es cuando todo el sistema deja de dar servicio al usuario.

#### 2. **Ejemplo:**

```javascript
// Escenario: Una app de m√∫sica
// FAULT (Falla):
// El servidor de "Recomendaciones" se cae por un error de memoria.
// Esto es un componente interno fallando.

// FAILURE (Fallo):
// Si la app muestra una pantalla blanca y no deja reproducir m√∫sica -> FAILURE.
// Si la app muestra la m√∫sica pero dice "Recomendaciones no disponibles" -> NO ES FAILURE.
```

**Explicaci√≥n del ejemplo:**
En el segundo caso, aunque hubo un _Fault_ (servidor ca√≠do), el sistema toler√≥ el error y evit√≥ el _Failure_ (el usuario sigui√≥ escuchando m√∫sica).

#### 3. **Desarrollo:**

**¬°Ojo aqu√≠!** Es imposible reducir la probabilidad de _Faults_ a cero (los discos duros mueren, la luz se corta). Por eso, tu objetivo como arquitecto no es evitar que las cosas se rompan (Faults), sino dise√±ar mecanismos que impidan que esas roturas detengan el servicio completo (Failures).

üî¥ **Fundamental:** Entender esta diferencia cambia tu mentalidad de "evitar errores" a "gestionar errores".

---

## C - Tolerancia a Fallas (Resiliencia): "Anticipar el desastre" [üü°]

#### 1. **Introducci√≥n:**

Un sistema tolerante a fallas es aquel dise√±ado asumiendo que los _Faults_ ocurrir√°n y tiene un plan B listo para ejecutarse autom√°ticamente.

#### 2. **Ejemplo:**

El **Chaos Monkey** de Netflix.

> Es un programa que Netflix usa para **apagar servidores aleatoriamente** en su propia red de producci√≥n, a prop√≥sito y sin avisar.

#### 3. **Desarrollo:**

Parece una locura (¬øromper tu propio sistema?), pero es genial. Al provocar _Faults_ deliberadamente, te obligas a ejercitar tus mecanismos de recuperaci√≥n. Si apagas un servidor y nadie se da cuenta, tu sistema es resiliente. Si apagas uno y Netflix se cae, acabas de encontrar un bug cr√≠tico antes que lo haga un usuario real.

üü° **Importante:** Aunque no todos implementan "Chaos Engineering", el concepto de dise√±ar pensando en que las cosas van a fallar es vital.

---

## D - Prevenci√≥n vs. Cura: "La excepci√≥n de Seguridad" [üîµ]

#### 1. **Introducci√≥n:**

Generalmente preferimos tolerar fallas (cura) que tratar de evitarlas todas (prevenci√≥n imposible). **PERO**, en seguridad, la prevenci√≥n es obligatoria.

#### 2. **Ejemplo:**

Si un hacker roba tu base de datos de usuarios:

- No hay "cura". No puedes "des-robar" los datos. El da√±o es irreversible.

#### 3. **Desarrollo:**

En la mayor√≠a de los casos de ingenier√≠a (servidores ca√≠dos, red lenta), buscamos la cura (recuperaci√≥n). En seguridad, como el evento no se puede deshacer, debemos invertir en prevenci√≥n absoluta.

üîµ **Espec√≠fico:** Es una distinci√≥n importante para no aplicar la filosof√≠a de "deja que falle" a temas de datos sensibles.

---

## E - Fallas de Hardware: "La rebeli√≥n de las m√°quinas" [üü°]

#### 1. **Introducci√≥n:**

Los discos duros mueren, la RAM se corrompe y alguien siempre desconecta el cable equivocado. Son fallas **aleatorias e independientes** (que falle el disco A no suele hacer que falle el disco B).

#### 2. **Ejemplo:**

**MTTF (Mean Time To Failure):** Un disco duro dura unos 10-50 a√±os.
Si tienes un cl√∫ster con **10,000 discos**, la estad√≠stica dice que **se morir√° un disco por d√≠a**.

#### 3. **Desarrollo:**

Tradicionalmente, esto se solucionaba con **Redundancia de Hardware** (RAID, fuentes de poder dobles). Si una pieza mor√≠a, la otra tomaba el control.
Sin embargo, en la nube moderna (AWS, Azure), se prioriza la flexibilidad sobre la robustez de una sola m√°quina. Las m√°quinas virtuales pueden desaparecer sin aviso. Por eso, la tendencia actual es **tolerar la p√©rdida de m√°quinas enteras mediante software**, no solo depender de hardware caro y redundante.

üü° **Importante:** Entender que el hardware _va_ a fallar te ayuda a no confiar ciegamente en que "el servidor es bueno".

---

## F - Errores de Software: "El enemigo silencioso" [üî¥]

#### 1. **Introducci√≥n:**

A diferencia del hardware, los errores de software son **sistem√°ticos y correlacionados**. Un bug en el c√≥digo puede hacer caer **todos** tus servidores al mismo tiempo.

#### 2. **Ejemplo:**

El "segundo intercalar" (leap second) de 2012.
Un bug en el kernel de Linux caus√≥ que muchas aplicaciones se colgaran **simult√°neamente** en todo el mundo cuando el reloj se ajust√≥ un segundo.

#### 3. **Desarrollo:**

Estos son m√°s peligrosos que los fallos de hardware porque suelen estar latentes (dormidos) hasta que una circunstancia inusual los despierta en todos los nodos a la vez. Incluyen procesos que consumen toda la CPU, servicios dependientes que responden basura, o **fallas en cascada** (un peque√±o error en A tumba a B, que tumba a C).

üî¥ **Fundamental:** Son la causa de la mayor√≠a de las ca√≠das catastr√≥ficas porque la redundancia de hardware no te salva de un bug de software replicado en todas las m√°quinas.

---

## G - Errores Humanos: "El factor caos" [üî¥]

#### 1. **Introducci√≥n:**

Aunque culpamos a las m√°quinas, los humanos (operadores, desarrolladores) causan la mayor√≠a de las interrupciones (configuraciones err√≥neas, despliegues fallidos).

#### 2. **Ejemplo:**

Un estudio de servicios de internet mostr√≥ que los errores de configuraci√≥n por operadores fueron la causa principal de ca√≠das, mientras que los fallos de hardware solo representaron el 10-25%.

#### 3. **Desarrollo:**

¬øC√≥mo nos protegemos de nosotros mismos?

1.  **Desacoplar:** Lugares para romper cosas (Sandboxes) separados de producci√≥n.
2.  **Minimizar oportunidades:** APIs que hagan dif√≠cil equivocarse.
3.  **Recuperaci√≥n r√°pida:** Botones de "Deshacer" (Rollback) r√°pidos para cambios de configuraci√≥n.
4.  **Telemetr√≠a:** Monitoreo constante para ver cu√°ndo nuestras acciones rompieron algo.

üî¥ **Fundamental:** Asumir que tu equipo cometer√° errores y darles herramientas para recuperarse r√°pido es mejor que tratar de prohibir los errores.

---

## H - Importancia de la Confiabilidad: "No es solo para la NASA" [‚ö™]

#### 1. **Introducci√≥n:**

La confiabilidad no es solo para plantas nucleares. Incluso en apps "no cr√≠ticas" (como una galer√≠a de fotos familiar), perder datos es inaceptable.

#### 2. **Ejemplo:**

Imagina que pierdes las fotos de los primeros pasos de tu hijo porque la base de datos de la app se corrompi√≥. El da√±o emocional y a la reputaci√≥n de la empresa es enorme.

#### 3. **Desarrollo:**

A veces sacrificamos confiabilidad por velocidad o costo (en prototipos), pero debemos ser **muy conscientes** de cu√°ndo estamos cortando camino. La responsabilidad √©tica con los datos del usuario existe siempre.

‚ö™ **Raramente usado (como concepto t√©cnico):** Es m√°s una filosof√≠a de negocio, pero vital para entender el "por qu√©" hacemos todo lo anterior.
