---
title: "1.01.04 - Mantenibilidad"
description: "Los tres pilares fundamentales para el dise침o de software a largo plazo: Operatividad, Simplicidad y Evolucionabilidad."
tags: ["architecture", "maintenance", "ops", "design-principles", "legacy"]
---

## A - Mantenibilidad: La Realidad Dolorosa del Software [游댮]

#### 1. Introducci칩n:

Es la capacidad de un sistema para ser modificado, corregido y adaptado a lo largo del tiempo con el menor dolor posible.

#### 2. Ejemplo:

Imagina que compras un coche.

- **Desarrollo inicial:** Es el d칤a que lo compras en el concesionario.
- **Mantenimiento:** Son los 15 a침os siguientes cambiando aceite, reparando frenos, cambiando neum치ticos y quiz치s instal치ndole un nuevo est칠reo.
- **Realidad:** Gastar치s mucho m치s dinero y tiempo en los 15 a침os de mantenimiento que en el d칤a de la compra. En software es igual.

#### 3. Desarrollo:

La mayor칤a de la gente piensa que el costo del software est치 en escribirlo la primera vez. **춰Error!** El mayor costo est치 en mantenerlo vivo: arreglar bugs, investigar fallos, pagar deuda t칠cnica y a침adir nuevas funciones.
Muchos odian trabajar en sistemas "Legacy" (heredados) porque suelen estar mal hechos. Nuestro objetivo es dise침ar software hoy para que no se convierta en una pesadilla "Legacy" para el pobre programador (que podr칤as ser t칰) del futuro.

游댮 **Fundamental:** Si no dise침as pensando en el mantenimiento, est치s creando un producto desechable y costoso.

## B - Los Tres Pilares del Dise침o de Software [游댮]

#### 1. Introducci칩n:

Son los tres principios que debemos vigilar obsesivamente para evitar crear software "basura".

#### 2. Ejemplo:

Piensa en un taburete de tres patas. Si falta una, te caes.

1.  **Operatividad:** Que sea f치cil de cuidar (para los administradores).
2.  **Simplicidad:** Que sea f치cil de entender (para los programadores).
3.  **Evolucionabilidad:** Que sea f치cil de cambiar (para el negocio).

#### 3. Desarrollo:

No hay una "soluci칩n m치gica" para lograr esto, pero debemos tenerlos en mente constantemente.

- **Nota paranoica:** No confundas estos t칠rminos con _Fiabilidad_ o _Escalabilidad_. Esos son atributos del rendimiento del sistema; estos tres son atributos de **c칩mo trabajamos con el sistema**.

游댮 **Fundamental:** Son la br칰jula que gu칤a todas las decisiones arquitect칩nicas en este texto.

## C - Operatividad: "S칠 amable con el SysAdmin" [游리]

#### 1. Introducci칩n:

Consiste en facilitar la vida a los equipos de operaciones para que el sistema funcione sin problemas.

#### 2. Ejemplo:

**Mala Operatividad:** El servidor se cae a las 3 AM y el 칰nico error que muestra es "Algo sali칩 mal". El administrador tiene que adivinar qu칠 pas칩.
**Buena Operatividad:** El servidor detecta un problema, se reinicia solo, y env칤a un log detallado diciendo: "Me qued칠 sin memoria en el proceso X".

#### 3. Desarrollo:

El texto cita una frase vital: _"Buenas operaciones pueden sortear un mal software, pero un buen software no puede correr fiablemente con malas operaciones"_.
Aunque automaticemos cosas, **los humanos** son quienes configuran esa automatizaci칩n. Si el sistema es opaco o caprichoso, el equipo de operaciones no podr치 mantenerlo estable.

游리 **Importante:** Sin buena operatividad, tu sistema perfecto en c칩digo ser치 un desastre en producci칩n.

## D - Responsabilidades del Equipo de Operaciones [游댯]

#### 1. Introducci칩n:

Lista de tareas vitales que realiza el equipo que mantiene el software vivo (y que tu c칩digo debe facilitar).

#### 2. Ejemplo:

No solo es "reiniciar el servidor". Incluye:

- Vigilar la salud del sistema (Monitoring).
- Rastrear la causa de problemas (Debugging).
- Instalar parches de seguridad.
- Planificar la capacidad (쯅ecesitaremos m치s discos el mes que viene?).
- Preservar el conocimiento del sistema cuando la gente renuncia.

#### 3. Desarrollo:

Tu trabajo como desarrollador es hacer que estas tareas sean **rutinarias y f치ciles**, para que ellos puedan concentrarse en problemas de alto valor en lugar de estar apagando fuegos constantemente.

游댯 **Espec칤fico:** Es vital entender esto para empatizar con quien desplegar치 tu c칩digo.

## E - Caracter칤sticas de un Sistema con Buena Operatividad [游리]

#### 1. Introducci칩n:

Cosas concretas que tu sistema debe tener para que Operaciones no te odie.

#### 2. Ejemplo:

- **Visibilidad:** "Tengo un panel que me dice cu치ntos usuarios hay conectados ahora mismo" (en lugar de una caja negra).
- **Independencia:** "Puedo apagar el servidor A para limpiarlo y el sistema sigue funcionando con el servidor B" (en lugar de que todo se caiga si tocas un cable).
- **Documentaci칩n:** "Si hago X, pasar치 Y" (Modelo predecible).

#### 3. Desarrollo:

Otras caracter칤sticas clave mencionadas:

- **Buenos valores por defecto:** Que funcione bien "reci칠n sacado de la caja", pero permita libertad para configurar si es necesario.
- **Auto-curaci칩n:** Que intente arreglarse solo, pero permita control manual si se vuelve loco.
- **Comportamiento predecible:** Minimizar las sorpresas. A los de operaciones no les gustan las sorpresas.

游리 **Importante:** Esta es tu "checklist" t칠cnica al construir servicios backend.

## F - Simplicidad: Gestionando la Complejidad [游댮]

#### 1. Introducci칩n:

Hacer que el sistema sea f치cil de entender para nuevos ingenieros eliminando la complejidad innecesaria.

#### 2. Ejemplo:

**Complejo:** Un c칩digo con 50 archivos interconectados, variables llamadas `x1`, `temp_2`, y trucos raros para ahorrar 1ms.
**Simple:** C칩digo limpio, m칩dulos separados y nombres claros.

**Explicaci칩n del ejemplo:**
Un proyecto complejo se convierte en una **"Gran Bola de Lodo"** (Big Ball of Mud). Nadie quiere tocarlo porque si mueves algo, rompes otra cosa que no sab칤as que estaba conectada.

#### 3. Desarrollo:

**춰Cuidado aqu칤!** El texto hace una distinci칩n cr칤tica:

- **Simplicidad de Interfaz de Usuario (UI):** Que sea f치cil para el cliente final.
- **Simplicidad de Sistema (Lo que hablamos aqu칤):** Que sea f치cil para el **programador**.
  La complejidad causa bugs. Si el c칩digo es dif칤cil de razonar, se esconder치n asunciones y consecuencias no deseadas.

游댮 **Fundamental:** La complejidad es el asesino silencioso de los proyectos de software a largo plazo.

## G - Complejidad Accidental vs. Complejidad Inherente [游댮]

#### 1. Introducci칩n:

La distinci칩n m치s importante para entender por qu칠 el software es dif칤cil.

#### 2. Ejemplo:

- **Complejidad Inherente (El problema real):** Calcular la trayectoria de un cohete a Marte. Es dif칤cil por naturaleza f칤sica y matem치tica. No puedes simplificarlo m치s all치 de cierto punto.
- **Complejidad Accidental (Nuestra culpa):** Escribir el programa del cohete en un lenguaje obsoleto, sin documentaci칩n y con variables en japon칠s siendo t칰 hispanohablante.

#### 3. Desarrollo:

- **Inherente:** Viene del problema que el usuario necesita resolver.
- **Accidental:** Surge solo de la implementaci칩n (mal dise침o, malas herramientas).
  **Moseley y Marks** definen la complejidad accidental como aquella que no es propia del problema. Nuestro trabajo es **eliminar la complejidad accidental**, no reducir la funcionalidad del sistema.

游댮 **Fundamental:** Debes saber distinguir si algo es dif칤cil porque el problema es dif칤cil, o porque tu c칩digo es un desastre.

## H - Abstracci칩n: La Herramienta de la Simplicidad [游리]

#### 1. Introducci칩n:

Es la mejor arma para eliminar la complejidad accidental: esconder los detalles feos detr치s de una fachada limpia.

#### 2. Ejemplo:

**SQL es una abstracci칩n.**
T칰 escribes: `SELECT * FROM usuarios`.
T칰 **NO** escribes: "Mueve el cabezal del disco duro al sector 45, lee los bits, decodif칤calos, verifica si hay colisiones de memoria con otros clientes..."

#### 3. Desarrollo:

Una buena abstracci칩n permite reutilizar componentes de alta calidad. Los lenguajes de alto nivel (Python, JS, Java) son abstracciones que esconden registros de CPU y llamadas al sistema.
**El reto:** En sistemas distribuidos, encontrar buenas abstracciones es muy dif칤cil. A lo largo del libro, buscaremos estas abstracciones.

游리 **Importante:** Entender que programamos sobre capas y capas de abstracciones nos ayuda a valorar la simplicidad.

## I - Evolucionabilidad: Haciendo el Cambio F치cil [游리]

#### 1. Introducci칩n:

La facilidad con la que los ingenieros pueden adaptar el sistema a requerimientos futuros inesperados.

#### 2. Ejemplo:

Hoy tu sistema solo acepta pagos con tarjeta. Ma침ana el negocio quiere aceptar Criptomonedas. Pasado ma침ana cambia la ley de impuestos.
Si tu sistema tiene buena **Evolucionabilidad**, estos cambios son fluidos. Si no, tendr치s que reescribir todo.

#### 3. Desarrollo:

Tambi칠n conocida como **extensibilidad**, **modificabilidad** o **plasticidad**.
Est치 totalmente ligada a la **Simplicidad** (Concepto F). Si un sistema es simple y tiene buenas abstracciones, es f치cil de cambiar. Si es una "Bola de Lodo", cambiarlo es un riesgo mortal.

游리 **Importante:** Los requisitos _siempre_ cambian. Dise침ar para un sistema est치tico es dise침ar para el fracaso.

## J - Agilidad vs. Evolucionabilidad (Diferencia de Escala) [游댯]

#### 1. Introducci칩n:

Diferenciamos las t칠cnicas 치giles cotidianas de la agilidad arquitect칩nica a gran escala.

#### 2. Ejemplo:

- **Agile / TDD / Refactoring:** Se enfoca en una escala peque침a y local (un par de archivos de c칩digo fuente, una funci칩n).
- **Evolucionabilidad (en este libro):** Se enfoca en la agilidad a nivel de **Sistema de Datos**.
  - _Caso:_ 쮺칩mo refactorizas la arquitectura entera de Twitter para cambiar c칩mo se arman los timelines de millones de usuarios? Eso es Evolucionabilidad.

#### 3. Desarrollo:

El texto usa el t칠rmino "Evolucionabilidad" para referirse a esta agilidad de alto nivel arquitect칩nico, diferenci치ndola de las pr치cticas de desarrollo 치gil del d칤a a d칤a, aunque el objetivo final es el mismo: adaptarse al cambio.

游댯 **Espec칤fico:** 칔til para entender el vocabulario espec칤fico que usar치 el autor en el resto del libro.
