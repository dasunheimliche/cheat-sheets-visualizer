---
title: "1.1.3 - Fundamentos de Escalabilidad"
description: "C√≥mo medir, describir y gestionar el crecimiento de sistemas (basado en DDIA Cap 1)"
tags: ["architecture", "scalability", "metrics", "performance"]
---

## A - Escalabilidad (La Definici√≥n Real) [üî¥]

#### 1. **Introducci√≥n:**

La escalabilidad no es una etiqueta de "s√≠ o no" que le pones a un sistema, sino la capacidad de mantener el rendimiento cuando aumenta la carga de trabajo.

#### 2. **Ejemplo:**

‚ùå **Mal:** "Mi servidor es escalable". (No significa nada).
‚úÖ **Bien:** "Si el tr√°fico se duplica, podemos agregar 2 servidores m√°s para mantener la misma velocidad de respuesta".

#### 3. **Desarrollo:**

[üî¥ Fundamental]: Es vital entender que decir "X es escalable" es un error de principiante. La escalabilidad es una respuesta a la pregunta: "¬øSi el sistema crece de forma X (ej: m√°s usuarios), qu√© opciones tenemos para lidiar con ese crecimiento?". No se trata de que funcione hoy, sino de que tengas un plan para cuando la carga aumente ma√±ana.

## B - Par√°metros de Carga [üü°]

#### 1. **Introducci√≥n:**

Son los n√∫meros espec√≠ficos que eliges para describir "cu√°nto trabajo" est√° haciendo tu sistema actualmente.

#### 2. **Ejemplo:**

- En un servidor web: **Peticiones por segundo**.
- En una base de datos: **Proporci√≥n de lecturas vs. escrituras**.
- En un chat: **Usuarios activos simult√°neos**.

#### 3. **Desarrollo:**

[üü° Importante]: No puedes hablar de crecimiento si no sabes d√≥nde est√°s parado. Antes de preguntar "¬øqu√© pasa si la carga se duplica?", debes definir qu√© es "carga" para _tu_ arquitectura espec√≠fica. A veces el cuello de botella no es el volumen total, sino unos pocos casos extremos.

## C - Fan-out (Abanico de salida) [üîµ]

#### 1. **Introducci√≥n:**

T√©rmino prestado de la electr√≥nica que describe cuando una sola petici√≥n de entrada genera una explosi√≥n de peticiones hacia otros servicios o usuarios.

#### 2. **Ejemplo:**

Un usuario famoso en Twitter publica **1 tweet** (entrada), pero ese tweet debe entregarse a sus **30 millones de seguidores** (salida masiva).

#### 3. **Desarrollo:**

[üîµ Espec√≠fico]: Es crucial en sistemas de redes sociales o mensajer√≠a. El reto de escalabilidad aqu√≠ no es procesar el mensaje original (que es f√°cil), sino gestionar la multiplicaci√≥n masiva de trabajo que ese mensaje provoca.

## D - Twitter Enfoque 1: Pull (Modelo Relacional) [üîµ]

#### 1. **Introducci√≥n:**

Guardar el tweet en una tabla global y, cuando un usuario quiere ver su timeline, buscar y ordenar los tweets de todos a los que sigue en ese momento.

#### 2. **Ejemplo:**

![Figure 1-2](https://i.imgur.com/yWib7jJ.png)

**Explicaci√≥n del ejemplo:**
Cuando "Jack" entra a ver sus tweets, el sistema hace una consulta SQL (`JOIN`) pesada en tiempo real para recolectar todo.

#### 3. **Desarrollo:**

[üîµ Espec√≠fico]: Este enfoque hace poco trabajo al **escribir** (solo guarda el tweet), pero much√≠simo trabajo al **leer** (tiene que buscar y ordenar cada vez). Twitter abandon√≥ esto al principio porque no aguantaba la carga de lecturas.

## E - Twitter Enfoque 2: Push (Fan-out on Write) [üîµ]

#### 1. **Introducci√≥n:**

Pre-calcular el timeline de cada usuario. Cuando alguien tuitea, el sistema inserta ese tweet inmediatamente en la "lista" (cach√©) de cada uno de sus seguidores.

#### 2. **Ejemplo:**

![Figure 1-3](https://i.imgur.com/7wreSEp.png)

**Explicaci√≥n del ejemplo:**
Si tengo 100 seguidores y tuiteo, el sistema hace 100 escrituras en las "cajas de entrada" de mis seguidores. Cuando ellos entran a leer, la lista ya est√° lista. ¬°Lectura instant√°nea!

#### 3. **Desarrollo:**

[üîµ Espec√≠fico]: Aqu√≠ invertimos la carga: la lectura es barata, pero la **escritura es cara**. El problema surge con los famosos (celebridades): un solo tweet de alguien con 30 millones de seguidores genera 30 millones de escrituras en segundos, causando retrasos.

## F - Twitter Enfoque H√≠brido [üü°]

#### 1. **Introducci√≥n:**

Usar el enfoque "Push" para usuarios normales y el enfoque "Pull" para celebridades con much√≠simos seguidores.

#### 2. **Ejemplo:**

- Si tuitea tu vecino (pocos seguidores) -> **Push** (se inserta en tu timeline).
- Si tuitea Justin Bieber (millones de seguidores) -> **Pull** (tu timeline lo busca y mezcla en el momento que abres la app).

#### 3. **Desarrollo:**

[üü° Importante]: Este es un gran ejemplo de c√≥mo no existe una "soluci√≥n √∫nica". Las arquitecturas maduras suelen combinar estrategias para cubrir los casos extremos que rompen el modelo simple.

## G - Throughput vs. Tiempo de Respuesta [üî¥]

#### 1. **Introducci√≥n:**

Diferencia clave en c√≥mo medimos velocidad: ¬øCu√°nto volumen procesamos (Throughput) o qu√© tan r√°pido contestamos a uno solo (Tiempo de Respuesta)?

#### 2. **Ejemplo:**

- **Throughput (Hadoop/Batch):** "Procesamos 500GB de datos por hora". (Importa el volumen total).
- **Tiempo de Respuesta (Web/Online):** "El usuario recibi√≥ la p√°gina en 200ms". (Importa la espera del usuario).

#### 3. **Desarrollo:**

[üî¥ Fundamental]: **¬°Cuidado aqu√≠!** No uses estas palabras indistintamente. En sistemas batch (procesamiento por lotes) optimizamos throughput. En sistemas online (donde hay un humano esperando), optimizamos tiempo de respuesta.

## H - Latencia vs. Tiempo de Respuesta [üî¥]

#### 1. **Introducci√≥n:**

A menudo se usan como sin√≥nimos, pero no lo son: la latencia es solo el tiempo de espera _antes_ de ser atendido; el tiempo de respuesta es el total.

#### 2. **Ejemplo:**

Vas a Starbucks:

- **Latencia:** El tiempo que pasas en la fila esperando a llegar a la caja.
- **Tiempo de Proceso:** El tiempo que tardan en hacer tu caf√©.
- **Tiempo de Respuesta:** Latencia + Tiempo de Proceso + Retrasos de red (tiempo total desde que entraste hasta que tienes el caf√©).

#### 3. **Desarrollo:**

[üî¥ Fundamental]: Soy paranoico con esto porque los desarrolladores suelen decir "tengo alta latencia" cuando en realidad tienen un procesamiento lento. La latencia es el tiempo que la petici√≥n pasa "latente" (esperando). El cliente ve el **Tiempo de Respuesta**.

## I - La Mentira del Promedio (Media Aritm√©tica) [üü°]

#### 1. **Introducci√≥n:**

El promedio (sumar todo y dividir) es una m√©trica enga√±osa porque oculta los problemas reales de los usuarios y no representa al usuario "t√≠pico".

#### 2. **Ejemplo:**

Si en un bar hay 9 personas que ganan 1.000‚Ç¨ y entra Bill Gates... el "promedio" de riqueza ser√° de millones de euros, pero eso no representa a nadie en el bar.

#### 3. **Desarrollo:**

[üü° Importante]: En sistemas web, es com√∫n tener muchos tiempos r√°pidos y unos pocos muy lentos (outliers). El promedio suaviza esos lentos y te hace creer que todo va bien cuando en realidad tienes usuarios furiosos. **No uses el promedio para medir rendimiento web.**

## J - Percentiles y Mediana (p50) [üî¥]

#### 1. **Introducci√≥n:**

La forma correcta de medir el rendimiento "t√≠pico". Ordenas todos los tiempos de respuesta de menor a mayor y tomas el valor que est√° justo en el medio.

#### 2. **Ejemplo:**

Tienes 100 peticiones. Las ordenas por velocidad.
Miras la petici√≥n n√∫mero 50. Tard√≥ **200ms**.
Esa es tu **Mediana (p50)**. Significa que el 50% de tus usuarios navegan m√°s r√°pido que eso, y el 50% m√°s lento.

#### 3. **Desarrollo:**

[üî¥ Fundamental]: La mediana es mucho mejor que el promedio porque es inmune a los outliers (ese Bill Gates del ejemplo anterior no altera la mediana). Si quieres saber cu√°nto espera un usuario normal, mira el p50.

## K - Tail Latency (Latencia de Cola - p95, p99) [üü°]

#### 1. **Introducci√≥n:**

M√©tricas para entender qu√© tan mal lo est√°n pasando tus usuarios m√°s lentos (los casos extremos o "la cola" de la distribuci√≥n).

#### 2. **Ejemplo:**

![Figure 1-4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781449373320/files/assets/ddia_0104.png)

**Explicaci√≥n del ejemplo:**
El **p95** es 1.5 segundos. Significa que 95 de cada 100 peticiones son r√°pidas (<1.5s), pero **5 de cada 100** son lentas (>1.5s).

#### 3. **Desarrollo:**

[üü° Importante]: ¬øPor qu√© nos importan esos pocos lentos? Porque en empresas como Amazon, esos usuarios suelen ser los que tienen m√°s datos (m√°s compras, m√°s historial), es decir, **los clientes VIP**. Optimizar el p99.9 es costoso, pero optimizar el p95 o p99 es vital para la satisfacci√≥n del cliente.

## L - SLAs y SLOs [üîµ]

#### 1. **Introducci√≥n:**

Contratos (SLA) y Objetivos (SLO) que definen formalmente qu√© se considera un servicio "funcional" usando percentiles.

#### 2. **Ejemplo:**

"El servicio se considera UP si el **p99** es menor a 1 segundo". (Si el 99% de las peticiones son r√°pidas, cumplimos el contrato. Si no, devolvemos dinero al cliente).

#### 3. **Desarrollo:**

[üîµ Espec√≠fico]: Las empresas serias no prometen "ser r√°pidos". Prometen n√∫meros exactos basados en percentiles.

## M - Head-of-line Blocking [üîµ]

#### 1. **Introducci√≥n:**

Cuando una petici√≥n lenta bloquea a todas las que vienen detr√°s, aunque las de atr√°s sean r√°pidas.

#### 2. **Ejemplo:**

Una caja de supermercado. Si la se√±ora de adelante tarda 10 minutos contando monedas, t√∫ (que solo traes un chicle) tienes que esperar 10 minutos. Tu tiempo de respuesta es horrible por culpa del bloqueo anterior.

#### 3. **Desarrollo:**

[üîµ Espec√≠fico]: Esto ocurre porque los servidores tienen capacidad limitada de procesamiento paralelo. Por eso es importante medir los tiempos en el **cliente**, no solo en el servidor, para capturar este tiempo de espera en la cola.

## N - Tail Latency Amplification [üü°]

#### 1. **Introducci√≥n:**

El efecto multiplicador de lentitud cuando una petici√≥n de usuario requiere llamar a muchos servicios backend en paralelo.

#### 2. **Ejemplo:**

![Figure 1-5](https://i.imgur.com/MIrSrha.png)

**Explicaci√≥n del ejemplo:**
Para cargar tu perfil, llamamos a 10 servicios. 9 responden r√°pido, pero 1 falla y tarda mucho. **Toda** tu petici√≥n se vuelve lenta.

#### 3. **Desarrollo:**

[üü° Importante]: Cuantos m√°s servicios llames, mayor es la probabilidad de que _al menos uno_ sea lento. Si tu p99 es lento, y llamas a 100 servicios, la mayor√≠a de tus usuarios finales sufrir√°n esa lentitud.

## O - Scale Up vs. Scale Out [üî¥]

#### 1. **Introducci√≥n:**

Las dos estrategias principales para a√±adir hardware: hacer la m√°quina m√°s grande o a√±adir m√°s m√°quinas.

#### 2. **Comparaci√≥n:**

- **Scale Up (Vertical):** Cambiar tu servidor por uno con m√°s RAM y CPU. (Como mudarse a una casa m√°s grande).
- **Scale Out (Horizontal):** Comprar 5 servidores peque√±os y repartir el trabajo. (Como comprar 5 apartamentos peque√±os).

#### 3. **Desarrollo:**

[üî¥ Fundamental]:

- **Scale Up:** M√°s simple (no hay que distribuir datos), pero muy caro y tiene un l√≠mite f√≠sico.
- **Scale Out:** M√°s complejo (arquitectura _shared-nothing_, hay que coordinar nodos), pero te√≥ricamente infinito y m√°s barato a gran escala.
- **Realidad:** Las buenas arquitecturas suelen ser h√≠bridas (varias m√°quinas bastante potentes).

## P - Sistemas El√°sticos vs. Manuales [üîµ]

#### 1. **Introducci√≥n:**

¬øQui√©n decide cu√°ndo a√±adir servidores? ¬øUn algoritmo o un humano?

#### 2. **Ejemplo:**

- **El√°stico:** Netflix detecta que es viernes noche y autom√°ticamente enciende 1000 servidores m√°s.
- **Manual:** El equipo de operaciones ve las gr√°ficas y decide comprar/configurar nuevos servidores para el mes que viene.

#### 3. **Desarrollo:**

[üîµ Espec√≠fico]: Lo el√°stico suena moderno y genial, pero a√±ade complejidad y puede comportarse de forma impredecible. El escalado manual es m√°s simple y seguro para sistemas donde la carga no cambia bruscamente de golpe.

## Q - Escalado Stateful vs. Stateless [üü°]

#### 1. **Introducci√≥n:**

La gran diferencia de dificultad al escalar: ¬øTu servidor guarda datos (Stateful) o solo procesa (Stateless)?

#### 2. **Ejemplo:**

- **Stateless (Web Server):** F√°cil. Pones 100 copias y listo. Si uno muere, no pasa nada.
- **Stateful (Base de Datos):** Dif√≠cil. Si pones 100 copias, ¬øc√≥mo mantienes los datos sincronizados en todas?

#### 3. **Desarrollo:**

[üü° Importante]: La sabidur√≠a convencional era "escala la base de datos verticalmente (m√°quina grande) y la web horizontalmente". Esto est√° cambiando con nuevas bases de datos distribuidas, pero sigue siendo mucho m√°s dif√≠cil escalar sistemas con estado (Stateful).

## R - El Mito de la "Salsa M√°gica" [‚ö™]

#### 1. **Introducci√≥n:**

No existe una arquitectura gen√©rica que sirva para todo. La escalabilidad depende totalmente de tus par√°metros de carga espec√≠ficos.

#### 2. **Ejemplo:**

Un sistema dise√±ado para 100.000 peticiones peque√±as (1kB) por segundo es radicalmente diferente a uno dise√±ado para 3 peticiones gigantes (2GB) por minuto.

#### 3. **Desarrollo:**

[‚ö™ Raramente usado como t√©rmino t√©cnico, pero vital como concepto]: No busques la "arquitectura escalable perfecta". Debes construir bas√°ndote en _tus_ supuestos de lectura/escritura. Si tus supuestos est√°n mal, tu escalabilidad fallar√°.
